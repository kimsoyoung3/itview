콘텐츠로 건너뛰기
나의 말:
public ContentDetailDTO getContentDetail(Integer contentId) {
ContentDetailDTO contentDetail = new ContentDetailDTO();

        // 컨텐츠 정보 조회
        ContentResponseDTO contentResponseDTO = contentRepository.findContentWithAvgRating(contentId);
        // 컨텐츠 장르 조회
        List<GenreDTO> genres = contentGenreRepository.findByContentId(contentId);
        genres.forEach(genre -> {
            contentResponseDTO.getGenres().add(genre.getGenre().getGenreName());
        });
        contentDetail.setContentInfo(contentResponseDTO);

        // 갤러리 이미지 조회
        List<ImageDTO> images = galleryRepository.findByContentId(contentId);
        contentDetail.setGallery(images);

        // 동영상 조회
        List<VideoDTO> videos = videoRepository.findByContentId(contentId);
        contentDetail.setVideos(videos);

        // 외부 서비스 조회
        List<ExternalServiceDTO> externalServices = externalServiceRepository.findByContentId(contentId);
        contentDetail.setExternalServices(externalServices);

        return contentDetail;
    } 해석 해줘
ChatGPT의 말:
이 Java 메서드는 특정 콘텐츠 ID에 대한 상세 정보를 조회하고, 그 정보를 ContentDetailDTO 객체로 반환하는 로직입니다. 전체적으로는 여러 저장소(repository)를 통해 콘텐츠와 관련된 정보들을 모아서 하나의 DTO로 구성하는 작업을 합니다. 각 줄을 자세히 해석해드릴게요.

🔍 메서드 시그니처
public ContentDetailDTO getContentDetail(Integer contentId)
contentId: 조회하고자 하는 콘텐츠의 고유 ID

반환 타입은 ContentDetailDTO: 콘텐츠의 상세 정보를 담는 DTO 클래스

📦 객체 생성
ContentDetailDTO contentDetail = new ContentDetailDTO();
최종적으로 정보를 담아 반환할 객체를 생성

1. 📄 콘텐츠 정보 + 평균 평점 조회
   ContentResponseDTO contentResponseDTO = contentRepository.findContentWithAvgRating(contentId);
   contentId에 해당하는 콘텐츠 정보를 조회

평균 평점 정보도 함께 조회 (findContentWithAvgRating 라는 이름에서 추정됨)

2. 🎭 콘텐츠 장르 조회 및 추가
   List<GenreDTO> genres = contentGenreRepository.findByContentId(contentId);
   genres.forEach(genre -> {
   contentResponseDTO.getGenres().add(genre.getGenre().getGenreName());
   });
   해당 콘텐츠가 가진 장르 목록을 가져옴

각각의 장르 이름을 contentResponseDTO의 genres 리스트에 추가

3. 📷 갤러리 이미지 조회
   List<ImageDTO> images = galleryRepository.findByContentId(contentId);
   contentDetail.setGallery(images);
   콘텐츠에 연관된 이미지들을 조회하고 contentDetail 객체에 설정

4. 🎥 동영상 조회
   List<VideoDTO> videos = videoRepository.findByContentId(contentId);
   contentDetail.setVideos(videos);
   콘텐츠에 연관된 동영상들을 조회하고 contentDetail 객체에 설정

5. 🌐 외부 서비스 조회
   List<ExternalServiceDTO> externalServices = externalServiceRepository.findByContentId(contentId);
   contentDetail.setExternalServices(externalServices);
   콘텐츠와 연결된 외부 서비스 정보 조회 후 설정

✅ 최종 결과 반환
return contentDetail;
모든 정보를 담은 ContentDetailDTO 객체를 반환

🧾 요약
이 메서드는 다음 정보를 종합해서 하나의 DTO에 담아 반환합니다:

항목	설명
콘텐츠 기본 정보	이름, 설명, 평균 평점 등
장르	콘텐츠에 연결된 장르명
갤러리 이미지	콘텐츠의 이미지 목록
동영상	콘텐츠 관련 영상 리스트
외부 서비스	넷플릭스, 왓챠 등 외부 플랫폼 정보 등
필요하시면 이 구조를 도식화해 드릴 수도 있습니다.

나의 말:
구조를 도식화
ChatGPT의 말:
아래는 해당 메서드가 데이터를 수집하고 ContentDetailDTO에 어떻게 구성하는지 도식화한 구조입니다.

📦 ContentDetailDTO 구조 (최종 반환 객체)
ContentDetailDTO
│
├── contentInfo: ContentResponseDTO
│   ├── title
│   ├── description
│   ├── avgRating
│   └── genres: List<String>
│         └── [ "드라마", "액션", "SF", ... ] ← 콘텐츠 장르 이름 목록
│
├── gallery: List<ImageDTO>
│     └── [ 이미지1, 이미지2, ... ]
│
├── videos: List<VideoDTO>
│     └── [ 영상1, 영상2, ... ]
│
└── externalServices: List<ExternalServiceDTO>
└── [ 서비스1, 서비스2, ... ]
🔄 데이터 흐름도
contentId
│
▼
contentRepository.findContentWithAvgRating(contentId)
└──> ContentResponseDTO ← 콘텐츠 기본 정보 + 평균 평점
(초기화된 genres 리스트 포함)
│
▼
contentGenreRepository.findByContentId(contentId)
└──> List<GenreDTO>
└──> 각 GenreDTO에서 genreName 추출하여
ContentResponseDTO.genres 리스트에 추가
│
▼
ContentDetailDTO.contentInfo = ContentResponseDTO
│
▼
galleryRepository.findByContentId(contentId)
└──> List<ImageDTO>
▼
ContentDetailDTO.gallery = List<ImageDTO>
│
▼
videoRepository.findByContentId(contentId)
└──> List<VideoDTO>
▼
ContentDetailDTO.videos = List<VideoDTO>
│
▼
externalServiceRepository.findByContentId(contentId)
└──> List<ExternalServiceDTO>
▼
ContentDetailDTO.externalServices = List<ExternalServiceDTO>

▼
return ContentDetailDTO
이 구조를 통해 한 콘텐츠에 대한 모든 연관 정보를 통합해 하나의 DTO에 담고, 프론트엔드나 API 호출자에게 풍부한 데이터를 제공하는 방식입니다.

필요하다면 이걸 클래스 다이어그램 형태로도 그려드릴 수 있어요.

나의 말:
구조를 도식화
ChatGPT의 말:
알겠어요! 좀 더 깔끔한 도식화(다이어그램) 형태로 보여드릴게요.

📊 콘텐츠 상세 정보 데이터 흐름도
+------------------+
|   contentId (입력)   |
+---------+--------+
|
v
+------------------------------+
| contentRepository.findContentWithAvgRating(contentId) |
+------------------------------+
|
v
+---------------------+
| ContentResponseDTO   |
| - title             |
| - description       |
| - avgRating         |
| - genres (빈 리스트) |
+---------------------+
|
v
+------------------------------+
| contentGenreRepository.findByContentId(contentId) |
+------------------------------+
|
v
+-----------------+
| List<GenreDTO>  |
| (장르 리스트)    |
+-----------------+
|
장르 이름을 ContentResponseDTO.genres에 추가
|
v
+---------------------+
| ContentResponseDTO   |
| - genres (장르명 포함)|
+---------------------+
|
v
+---------------------+
| ContentDetailDTO     |
| - contentInfo       |
+---------------------+
|
v
+------------------------------+
| galleryRepository.findByContentId(contentId) |
+------------------------------+
|
v
+---------------------+
| List<ImageDTO>      |
+---------------------+
|
v
+---------------------+
| ContentDetailDTO     |
| - gallery           |
+---------------------+
|
v
+------------------------------+
| videoRepository.findByContentId(contentId) |
+------------------------------+
|
v
+---------------------+
| List<VideoDTO>      |
+---------------------+
|
v
+---------------------+
| ContentDetailDTO     |
| - videos            |
+---------------------+
|
v
+------------------------------+
| externalServiceRepository.findByContentId(contentId) |
+------------------------------+
|
v
+---------------------------+
| List<ExternalServiceDTO>  |
+---------------------------+
|
v
+---------------------+
| ContentDetailDTO     |
| - externalServices  |
+---------------------+
|
v
+---------------------+
|  최종 반환 (return)  |
+---------------------+
이 그림은 콘텐츠 ID를 받아서 여러 저장소(repository)에서 정보를 조회하고, 이 정보를 모아서 ContentDetailDTO 객체에 채워 최종 반환하는 흐름을 보여줍니다.

필요하면 UML 클래스 다이어그램도 만들어 드릴게요!

나의 말:
UML 클래스 다이어그램
ChatGPT의 말:
좋아요! 아래는 메서드에서 사용된 주요 DTO들과 그 관계를 나타낸 UML 클래스 다이어그램입니다.

+-----------------------+
|   ContentDetailDTO    |
+-----------------------+
| - contentInfo: ContentResponseDTO  |
| - gallery: List<ImageDTO>           |
| - videos: List<VideoDTO>            |
| - externalServices: List<ExternalServiceDTO> |
+-----------------------+

            1
            |
            |
            | 1
+--------------------------+
| ContentResponseDTO        |
+--------------------------+
| - title: String           |
| - description: String     |
| - avgRating: Float        |
| - genres: List<String>    |  <---------+
+--------------------------+            |
*|  
0..*                       +----------------+
+-----------------------+             |   GenreDTO     |
|      GenreDTO         |             +----------------+
+-----------------------+             | - genre: Genre |
| - genre: Genre         |             +----------------+
+-----------------------+
|
| 1
|
+-----------------------+
|       Genre           |
+-----------------------+
| - genreName: String   |
+-----------------------+

+-----------------------+
|      ImageDTO         |
+-----------------------+
| - imageUrl: String    |
| - description: String |
+-----------------------+

+-----------------------+
|      VideoDTO         |
+-----------------------+
| - videoUrl: String    |
| - title: String       |
+-----------------------+

+-----------------------------+
|   ExternalServiceDTO        |
+-----------------------------+
| - serviceName: String       |
| - serviceUrl: String        |
+-----------------------------+
설명
ContentDetailDTO 가 최상위 객체로, 여러 리스트와 상세 콘텐츠 정보를 가지고 있습니다.

ContentResponseDTO 는 콘텐츠의 기본 정보 + 장르 리스트를 포함합니다.

장르는 GenreDTO 와 Genre 클래스를 통해 관리되고, 최종적으로 장르 이름(genreName)이 ContentResponseDTO의 문자열 리스트에 들어갑니다.

갤러리 이미지(ImageDTO), 동영상(VideoDTO), 외부 서비스(ExternalServiceDTO)는 각각 리스트 형태로 ContentDetailDTO에 포함됩니다.

필요하면 이걸 시각적인 UML 다이어그램 이미지로도 만들어 드릴 수 있어요!

나의 말:
package com.example.itview_spring.Entity;

import lombok.Getter;
import lombok.Setter;

import java.time.LocalDateTime;
import java.util.List;

import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import jakarta.persistence.CascadeType;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EntityListeners;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.OneToMany;
import lombok.AllArgsConstructor;
import lombok.NoArgsConstructor;

@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
@Entity
@EntityListeners(AuditingEntityListener.class)
public class CollectionEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;

    // 컬렉션 소유자
    @JoinColumn(name = "user_id", nullable = false)
    @ManyToOne(fetch = FetchType.LAZY)
    private UserEntity user;

    // 컬렉션 이름
    @Column(nullable = false, length = 255)
    private String title;

    // 컬렉션 생성 시간
    @CreatedDate
    @Column(nullable = false, updatable = false)
    private LocalDateTime createdAt;

    // 컬렉션 수정 시간
    @LastModifiedDate
    @Column(nullable = false)
    private LocalDateTime updatedAt;

    // 컬렉션 설명
    @Column(length = 1024)
    private String description;

    // 컬렉션의 아이템
    @OneToMany(mappedBy = "collection", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<CollectionItemEntity> items;
} 수정할곳은 ?
ChatGPT의 말:
전체적으로 잘 작성된 JPA 엔티티입니다!
다만, 몇 가지 최적화나 개선할 부분 및 주의해야 할 점을 짚어드릴게요.

1. @EntityListeners와 Auditing 설정 관련
   @EntityListeners(AuditingEntityListener.class) 를 썼으면, 스프링 부트에서 JPA Auditing 활성화가 필요합니다.
   보통 @EnableJpaAuditing을 메인 애플리케이션 클래스나 설정 클래스에 달아야 합니다.
   (이건 코드가 아니라 설정 체크사항입니다.)

2. @ManyToOne(fetch = FetchType.LAZY)와 @JoinColumn
   지금처럼 @ManyToOne(fetch = FetchType.LAZY) 설정은 좋습니다.

다만 nullable = false 를 @JoinColumn에 명시하는 것이 좋습니다. 현재도 명시되어 있는데, @ManyToOne에도 optional = false를 추가하면 JPA가 좀 더 명확히 인식합니다.

@ManyToOne(fetch = FetchType.LAZY, optional = false)
@JoinColumn(name = "user_id", nullable = false)
private UserEntity user;
3. @OneToMany 매핑
   mappedBy = "collection" 로 연관관계를 맺은 부분이 문제 없으면 그대로 두면 됩니다.

cascade = CascadeType.ALL, orphanRemoval = true 는 컬렉션 내 아이템 생명주기 관리를 잘 처리해줘서 적절해 보입니다.

4. 생성/수정 날짜 필드 타입과 기본값
   @CreatedDate, @LastModifiedDate는 LocalDateTime과 잘 맞습니다.

근데 데이터베이스에 따라 TIMESTAMP 타입으로 매핑되는지, 필요한 경우 @Column(columnDefinition = "TIMESTAMP")를 추가하는 것도 고려하세요. (필수는 아님)

5. 추가 권장사항: toString(), equals(), hashCode() 처리
   Lombok을 쓰셨으니 @ToString(exclude = "user"), @EqualsAndHashCode(exclude = "user") 같은 어노테이션으로 무한참조 방지 권장합니다.

특히 양방향 연관관계에서 toString 호출 시 StackOverflowError 발생 가능성 있음.

예시:

@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
@Entity
@EntityListeners(AuditingEntityListener.class)
@ToString(exclude = "user")
@EqualsAndHashCode(exclude = "user")
public class CollectionEntity {
...
}
6. Optional: 필드 주석 한글 → 영어 (팀 협업 시)
   코드 주석을 영어로 작성하는 것이 글로벌 스탠다드에 맞춰 추천되긴 합니다.

(팀 문화나 환경에 따라 달라질 수 있음)

정리
@ManyToOne(fetch = FetchType.LAZY, optional = false)
@JoinColumn(name = "user_id", nullable = false)
private UserEntity user;
@ToString(exclude = "user")
@EqualsAndHashCode(exclude = "user")
JPA Auditing 활성화 여부 확인(@EnableJpaAuditing)

필요 시 날짜 타입 컬럼 정의 확인

필요하면 UserEntity와 CollectionItemEntity 관계도 같이 봐드릴 수 있습니다.
궁금한 점 있으면 알려주세요!

나의 말:
package com.example.itview_spring.Entity;

import lombok.Getter;
import lombok.Setter;

import java.util.List;

import com.example.itview_spring.Constant.Role;

import jakarta.persistence.CascadeType;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.OneToMany;
import lombok.AllArgsConstructor;
import lombok.NoArgsConstructor;

@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
@Entity
public class UserEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;

    // 유저 역할 (예: ADMIN, USER 등)
    @Column(nullable = false, length = 255)
    @Enumerated(EnumType.STRING)
    private Role role;

    // 유저 닉네임
    @Column(nullable = false, length = 255)
    private String nickname;

    // 유저 이메일
    @Column(nullable = false, length = 255)
    private String email;

    // 유저 비밀번호
    @Column(nullable = false, length = 255)
    private String password;

    // 유저 프로필 사진 링크
    @Column(length = 1024)
    private String profile;

    // 유저 소개
    @Column(length = 1024)
    private String introduction;

    // 유저의 컬렉션 목록
    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<CollectionEntity> collections;

    // 유저의 코멘트 목록
    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<CommentEntity> comments;

    // 유저의 평점 목록
    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<RatingEntity> ratings;

    // 유저의 위시리스트 목록
    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<WishlistEntity> wishlists;

    // 유저의 댓글 목록
    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<ReplyEntity> replies;

    // 유저의 좋아요 목록
    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<LikeEntity> likes;

    // 유저의 이메일 인증 목록
    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<EmailVerificationEntity> emailVerifications;

    // 유저의 소셜 계정 목록
    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<SocialEntity> socials;
} 수정할곳은  
ChatGPT의 말:
잘 작성된 UserEntity입니다!
다만, 다음 부분들은 개선 또는 주의가 필요한 부분입니다.

1. 연관관계에 의한 성능 문제 및 무한참조 주의
   @OneToMany 관계가 매우 많습니다. (9개 이상)

이런 다수의 양방향 연관관계는 엔티티 로딩 시 성능 이슈나, JSON 직렬화 시 무한참조(StackOverflowError) 문제를 유발할 수 있습니다.

해결책
직렬화 관련 어노테이션 추가

예를 들어, Jackson 사용할 경우 @JsonManagedReference / @JsonBackReference

혹은 @JsonIgnore를 통해 직렬화 제외 처리

Lombok @ToString과 @EqualsAndHashCode에서 연관관계 필드 제외

무한참조 방지를 위해 다음 예시처럼 사용하세요:

@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
@Entity
@ToString(exclude = {"collections", "comments", "ratings", "wishlists", "replies", "likes", "emailVerifications", "socials"})
@EqualsAndHashCode(exclude = {"collections", "comments", "ratings", "wishlists", "replies", "likes", "emailVerifications", "socials"})
public class UserEntity {
//...
}
2. 연관관계의 Fetch 타입 지정
   기본적으로 @OneToMany는 FetchType.LAZY가 기본입니다. 하지만 명시적으로 지정해주는 것이 좋습니다.

@OneToMany(mappedBy = "user", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
private List<CollectionEntity> collections;
// 나머지도 동일하게
3. 컬렉션 타입 초기화
   컬렉션 필드는 보통 null이 아닌 빈 컬렉션으로 초기화해두는 것이 안전합니다. (예: private List<CollectionEntity> collections = new ArrayList<>();)

이 방법은 NPE 방지에 도움됩니다.

4. 필드 주석 영어화 (선택사항)
   협업 시 영어 주석 권장

5. 패스워드 보안
   password 필드는 암호화된 값이 저장되어야 하며, 실제 암호화 로직은 별도에서 관리합니다. (코드상 문제는 아니지만 주의사항)

6. Optional: UserEntity 클래스에 Auditing 추가
   생성/수정일 필드를 추가하는 경우가 많으니 필요하면 추가 가능 (지금은 없어도 무방)

종합 수정 예시 (일부 발췌)
@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
@Entity
@ToString(exclude = {"collections", "comments", "ratings", "wishlists", "replies", "likes", "emailVerifications", "socials"})
@EqualsAndHashCode(exclude = {"collections", "comments", "ratings", "wishlists", "replies", "likes", "emailVerifications", "socials"})
public class UserEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;

    @Column(nullable = false, length = 255)
    @Enumerated(EnumType.STRING)
    private Role role;

    @Column(nullable = false, length = 255)
    private String nickname;

    @Column(nullable = false, length = 255)
    private String email;

    @Column(nullable = false, length = 255)
    private String password;

    @Column(length = 1024)
    private String profile;

    @Column(length = 1024)
    private String introduction;

    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private List<CollectionEntity> collections = new ArrayList<>();

    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private List<CommentEntity> comments = new ArrayList<>();

    // 나머지 필드들도 동일하게 fetch=LAZY, 초기화
    ...
}
필요하면 @JsonIgnore나 @JsonManagedReference 추가하는 방법도 알려드릴게요!
궁금한 점 있으면 편하게 물어봐 주세요 :)

나의 말:
package com.example.itview_spring.Entity;

import lombok.Getter;
import lombok.Setter;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import lombok.AllArgsConstructor;
import lombok.NoArgsConstructor;

@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
@Entity
public class VideoEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;

    // 컨텐츠
    @JoinColumn(name = "content_id", nullable = false)
    @ManyToOne(fetch = FetchType.LAZY)
    private ContentEntity content;

    // 비디오 제목
    @Column(nullable = false, length = 255)
    private String title;

    // 비디오 썸네일 URL
    @Column(nullable = false, length = 1024)
    private String image;

    // 비디오 URL
    @Column(nullable = false, length = 1024)
    private String url;
} 수정할곳은  
ChatGPT의 말:
VideoEntity 코드도 전반적으로 잘 작성되었어요!
다만, 몇 가지 권장 사항 및 개선점 짚어드릴게요.

1. @ManyToOne에 optional = false 명시
   nullable = false를 @JoinColumn에 지정했으니, @ManyToOne에도 optional = false를 추가하는 게 명확합니다.

@ManyToOne(fetch = FetchType.LAZY, optional = false)
@JoinColumn(name = "content_id", nullable = false)
private ContentEntity content;
2. 필드 주석 영어화 (선택 사항)
   팀 협업 환경에 따라 영어 주석 권장

3. (선택) Lombok @ToString과 @EqualsAndHashCode에서 연관관계 필드 제외
   만약 엔티티를 toString()으로 출력할 일이 있으면, LAZY 로딩된 연관 필드가 문제될 수 있어 제외하는 것이 좋습니다.

@ToString(exclude = "content")
@EqualsAndHashCode(exclude = "content")
4. (선택) URL 필드 길이 적절성 검토
   URL 길이가 1024로 넉넉한 편이긴 한데, 실제 필요에 따라 조정 가능 (현재는 문제 없음)

수정된 코드 예시
@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
@Entity
@ToString(exclude = "content")
@EqualsAndHashCode(exclude = "content")
public class VideoEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;

    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "content_id", nullable = false)
    private ContentEntity content;

    @Column(nullable = false, length = 255)
    private String title;

    @Column(nullable = false, length = 1024)
    private String image;

    @Column(nullable = false, length = 1024)
    private String url;
}
필요하면 ContentEntity와의 관계 설정도 같이 봐드릴 수 있습니다.
추가 질문 있으시면 말씀해 주세요!

나의 말:
package com.example.itview_spring.Entity;

import lombok.Getter;
import lombok.Setter;

import java.time.LocalDate;
import java.util.List;

import com.example.itview_spring.Constant.Channel;
import com.example.itview_spring.Constant.ContentType;

import jakarta.persistence.CascadeType;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Lob;
import jakarta.persistence.OneToMany;
import lombok.AllArgsConstructor;
import lombok.NoArgsConstructor;

@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
@Entity
public class ContentEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;

    // 컨텐츠 제목
    @Column(nullable = false, length = 255)
    private String title;

    // 컨텐츠 타입
    @Column(nullable = false, length = 255)
    @Enumerated(EnumType.STRING)
    private ContentType contentType;

    // 컨텐츠 공개일
    @Column(nullable = false)
    private LocalDate releaseDate;

    // 컨텐츠 포스터 이미지 URL
    @Column(nullable = false, length = 1024)
    private String poster;

    // 컨텐츠 국가
    @Column(nullable = false, length = 255)
    private String nation;

    // 컨텐츠 설명
    @Lob
    private String description;

    // 컨텐츠 길이
    @Column(nullable = false, length = 255)
    private String duration;

    // 컨텐츠 연령 등급
    @Column(nullable = false, length = 255)
    private String age;

    // 영화-감독이름, 책-작가이름, 음반-아티스트이름
    @Column(length = 255)
    private String creatorName;

    // 플랫폼 이름
    @Column(length = 255)
    @Enumerated(EnumType.STRING)
    private Channel channelName;

    // 컨텐츠의 장르
    @OneToMany(mappedBy = "content", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<ContentGenreEntity> genres;

    // 컨텐츠의 출연진
    @OneToMany(mappedBy = "content", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<CreditEntity> credits;

    // 컨텐츠의 갤러리 이미지
    @OneToMany(mappedBy = "content", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<GalleryEntity> galleries;

    // 컨텐츠의 비디오
    @OneToMany(mappedBy = "content", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<VideoEntity> videos;

    // 컨텐츠의 외부 서비스
    @OneToMany(mappedBy = "content", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<ExternalServiceEntity> externalServices;

    // 컨텐츠의 코멘트
    @OneToMany(mappedBy = "content", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<CommentEntity> comments;

    // 컨텐츠의 평점
    @OneToMany(mappedBy = "content", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<RatingEntity> ratings;

    // 컨텐츠의 위시리스트
    @OneToMany(mappedBy = "content", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<WishlistEntity> wishlists;

    // 컨텐츠의 컬렉션 아이템
    @OneToMany(mappedBy = "content", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<CollectionItemEntity> collectionItems;
} 수정할곳은
ChatGPT의 말:
ContentEntity도 아주 잘 작성되어 있어요!
몇 가지 개선 포인트와 권장사항만 안내해 드릴게요.

1. @OneToMany 필드의 FetchType 명시
   기본적으로 @OneToMany는 FetchType.LAZY이지만, 명시적으로 적어주면 가독성, 유지보수성 향상에 도움이 됩니다.

@OneToMany(mappedBy = "content", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
private List<ContentGenreEntity> genres;
모든 @OneToMany 필드에 동일하게 적용하는 게 좋아요.

2. @Lob 사용 시 주의사항
   description 필드에 @Lob이 적절히 사용되었는데,
   DB에 따라 TEXT 또는 CLOB 타입으로 매핑됩니다.

만약 description이 크게 길어질 가능이 없으면 그냥 @Column(length=...)도 충분할 수 있습니다.

3. duration 필드 타입 검토
   duration을 String으로 정의했는데,
   만약 컨텐츠 길이가 시간/분 단위 숫자라면 int나 Duration 타입도 고려해 보세요.

4. @Enumerated(EnumType.STRING) 위치
   channelName 필드는 @Column과 @Enumerated가 함께 있는데, 순서가 보통 @Enumerated가 먼저 옵니다.

@Enumerated(EnumType.STRING)
@Column(length = 255)
private Channel channelName;
이 부분은 큰 문제는 아니지만 보통 이렇게 씁니다.

5. Lombok @ToString / @EqualsAndHashCode에서 연관 필드 제외 권장
   양방향 연관관계가 많아서 toString()이나 equals() 호출 시 무한참조 문제가 발생할 수 있습니다.

@ToString(exclude = {
"genres", "credits", "galleries", "videos", "externalServices",
"comments", "ratings", "wishlists", "collectionItems"
})
@EqualsAndHashCode(exclude = {
"genres", "credits", "galleries", "videos", "externalServices",
"comments", "ratings", "wishlists", "collectionItems"
})
6. 컬렉션 필드 초기화 (선택사항)
   컬렉션 필드를 null이 아닌 빈 컬렉션(new ArrayList<>();)으로 초기화하는 것도 NPE 방지에 도움이 됩니다.

7. (선택) Auditing 컬럼 추가
   createdAt, updatedAt 같은 생성/수정 일자 컬럼 추가 고려 가능

최종 수정 예시 (핵심 부분만 발췌)
@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
@Entity
@ToString(exclude = {
"genres", "credits", "galleries", "videos", "externalServices",
"comments", "ratings", "wishlists", "collectionItems"
})
@EqualsAndHashCode(exclude = {
"genres", "credits", "galleries", "videos", "externalServices",
"comments", "ratings", "wishlists", "collectionItems"
})
public class ContentEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;

    @Column(nullable = false, length = 255)
    private String title;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 255)
    private ContentType contentType;

    @Column(nullable = false)
    private LocalDate releaseDate;

    @Column(nullable = false, length = 1024)
    private String poster;

    @Column(nullable = false, length = 255)
    private String nation;

    @Lob
    private String description;

    @Column(nullable = false, length = 255)
    private String duration;

    @Column(nullable = false, length = 255)
    private String age;

    @Column(length = 255)
    private String creatorName;

    @Enumerated(EnumType.STRING)
    @Column(length = 255)
    private Channel channelName;

    @OneToMany(mappedBy = "content", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private List<ContentGenreEntity> genres;

    // 나머지도 동일하게 fetch = FetchType.LAZY 추가
}
필요하면 연관된 엔티티 관계 설정도 같이 점검해 드릴 수 있습니다.
궁금한 점 있으면 언제든 물어보세요!

나의 말:
package com.example.itview_spring.DTO;

import com.example.itview_spring.Constant.Channel;
import com.example.itview_spring.Constant.ContentType;
import com.example.itview_spring.Constant.Genre;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.time.LocalDate;
import java.util.List;

@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
public class ContentCreateDTO {
private Integer id;
private String title;
private ContentType contentType;
private LocalDate releaseDate;
private String poster;
private String nation;
private String description;
private String duration;
private String age;
private String creatorName;
private Channel channelName;
// 선택 사항: genre 필드 추가
private List<Genre> genres;
}  수정할곳 은  
ChatGPT의 말:
ContentCreateDTO는 DTO라 크게 문제가 없지만, 몇 가지 개선 포인트만 말씀드릴게요.

1. id 필드 제거 고려
   보통 생성용 DTO(CreateDTO)에는 id 필드가 포함되지 않습니다.

왜냐하면 생성 시 DB에서 자동 생성되기 때문입니다.

만약 클라이언트에서 ID를 전달할 특별한 이유가 없다면 제거하는 게 좋습니다.

2. genres 필드 타입 검토
   현재 List<Genre>인데, Genre가 Enum이라면 괜찮습니다.

하지만, 보통 장르는 DB에서 별도 엔티티로 관리되는 경우가 많고, 클라이언트가 문자열 리스트(List<String>)로 보내기도 합니다.

만약 Genre가 Enum이 맞다면 괜찮고, 아니라면 DTO 설계에 맞게 변경 고려.

3. (선택) @Builder 추가 고려
   DTO 생성 편의 위해 Lombok의 @Builder를 추가할 수 있습니다.

@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
@Builder
public class ContentCreateDTO {
// ...
}
4. (선택) 입력 검증 어노테이션 추가
   예를 들어, javax.validation.constraints 어노테이션을 활용하여 입력 검증 추가 가능

@NotNull
@Size(min = 1, max = 255)
private String title;
수정 예시
@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
//@Builder  // 필요 시 활성화
public class ContentCreateDTO {
// id는 생성용 DTO에서는 보통 제외
private String title;
private ContentType contentType;
private LocalDate releaseDate;
private String poster;
private String nation;
private String description;
private String duration;
private String age;
private String creatorName;
private Channel channelName;

    // Enum 타입이면 그대로 사용 가능
    private List<Genre> genres;
}
필요하면 ContentUpdateDTO도 같이 설계해 드릴 수 있습니다.
추가 질문 환영해요!

나의 말:
package com.example.itview_spring.DTO;

import com.example.itview_spring.Constant.Channel;
import com.example.itview_spring.Constant.ContentType;
import com.example.itview_spring.Constant.Genre;
import com.example.itview_spring.Entity.ContentEntity;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import org.hibernate.mapping.List;

import java.time.LocalDate;

@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
public class GenreListDTO {
private Integer id;            // 장르 ID (수정 시 필요)
private ContentEntity content; //컨텐츠
private Genre genre;           // 장르 ENUM
}  수정할곳은  
ChatGPT의 말:
GenreListDTO 코드에 몇 가지 수정 및 개선할 부분이 보여요.
아래 참고하세요!

1. import org.hibernate.mapping.List; 삭제
   DTO에서 java.util.List가 아닌 org.hibernate.mapping.List를 import 하셨네요.

DTO 내부에 List 타입 필드가 없으므로 이 import 자체가 필요 없어 보입니다. 삭제하세요.

2. DTO에 ContentEntity 필드가 있는 것 재검토
   DTO는 Entity를 직접 참조하는 대신 별도의 DTO로 매핑하는 게 일반적인 베스트 프랙티스입니다.

ContentEntity 대신 ContentDTO 혹은 단순히 contentId만 가지는 게 좋습니다.

Entity 참조는 직렬화, 계층 분리에서 문제를 일으킬 수 있습니다.

3. DTO 이름과 용도 정리
   클래스 이름이 GenreListDTO인데 실제 필드는 장르 하나에 대한 정보 같습니다.

복수형 이름 대신 GenreDTO 또는 ContentGenreDTO 같은 이름이 더 명확합니다.

4. id 필드 설명
   주석에 ‘장르 ID (수정 시 필요)’라고 하셨는데, DTO 생성 목적에 따라 달라집니다.

생성용 DTO면 id 제외, 수정용이면 포함.

5. (선택) Lombok Builder 추가 고려
   수정 예시
   @Getter
   @Setter
   @AllArgsConstructor
   @NoArgsConstructor
   public class ContentGenreDTO {
   private Integer id;        // 장르 ID (필요 시 포함)
   private Integer contentId; // contentId로 대체 (Entity 직접 참조 대신)
   private Genre genre;       // 장르 ENUM
   }
   필요하면 관련 컨텐츠 DTO와 매핑 코드도 같이 도와드릴게요!
   더 궁금한 점 있으면 알려주세요 :)

나의 말:
위자료 참조해서 videoDTO 작성해줘
ChatGPT의 말:
아래는 VideoEntity를 참고해서 만든 VideoDTO 예시입니다.
DTO는 엔티티와 거의 동일하지만, 보통 연관 엔티티는 ID 또는 별도의 DTO로 대체하고, 불필요한 JPA 어노테이션은 제외합니다.

package com.example.itview_spring.DTO;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
public class VideoDTO {

    private Integer id;

    // 연관된 컨텐츠 ID만 포함 (ContentEntity 대신)
    private Integer contentId;

    private String title;

    private String image;  // 썸네일 URL

    private String url;    // 비디오 URL
}
설명
contentId 필드를 추가해 VideoEntity의 content 참조 대신 컨텐츠 ID만 저장합니다.

Lombok으로 기본 생성자, 전체 생성자, getter/setter 자동 생성.

JPA 관련 어노테이션은 제거하여 DTO 역할에 집중.

필요 시 변환 메서드(converter)도 같이 만들어 드릴 수 있습니다!
더 요청사항 있으면 알려 주세요.

나의 말:
videoreporstrory 작성 요
ChatGPT의 말:
VideoRepository는 VideoEntity에 대한 데이터 접근을 담당하는 JPA 리포지토리입니다.

아래는 스프링 데이터 JPA를 사용하는 기본적인 VideoRepository 예제입니다:

package com.example.itview_spring.Repository;

import com.example.itview_spring.Entity.VideoEntity;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface VideoRepository extends JpaRepository<VideoEntity, Integer> {

    // contentId로 Video 리스트 조회
    List<VideoEntity> findByContentId(Integer contentId);

}
설명
JpaRepository<VideoEntity, Integer>: VideoEntity를 기본 Entity로, 기본키 타입은 Integer임을 지정.

findByContentId(Integer contentId):
VideoEntity 내부의 content 필드에서 content_id 기준으로 동영상 목록을 가져오는 메서드.
(JPA가 내부적으로 content.id와 매칭)

필요하다면 커스텀 쿼리 작성, 페이징 처리 등도 추가할 수 있습니다.
추가 요청 있으면 편하게 말씀해 주세요!

나의 말:
업로드한 이미지
와 같이 작성할때 service 입력 수정  작성요함
ChatGPT의 말:
이미지에 나타난 UI는 동영상 등록/수정 화면으로, 사용자 입력에 따라 썸네일 링크, 영상 링크, 제목을 작성하고 여러 개의 동영상을 등록하거나 수정할 수 있도록 되어 있습니다.

이런 기능을 처리하기 위한 VideoService 코드를 아래와 같이 설계할 수 있습니다.

✅ 1. Video 등록/수정용 DTO 예시 (VideoDTO or VideoCreateDTO)
@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
public class VideoCreateDTO {
private Integer id;          // 수정 시 필요
private Integer contentId;   // 어느 콘텐츠에 속하는 비디오인지
private String title;        // 제목
private String image;        // 썸네일 링크
private String url;          // 영상 링크
}
✅ 2. VideoService 작성 예시
package com.example.itview_spring.Service;

import com.example.itview_spring.DTO.VideoCreateDTO;
import com.example.itview_spring.Entity.ContentEntity;
import com.example.itview_spring.Entity.VideoEntity;
import com.example.itview_spring.Repository.ContentRepository;
import com.example.itview_spring.Repository.VideoRepository;
import jakarta.transaction.Transactional;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class VideoService {

    private final VideoRepository videoRepository;
    private final ContentRepository contentRepository;

    // 동영상 등록
    @Transactional
    public void createVideos(List<VideoCreateDTO> videoDTOList) {
        for (VideoCreateDTO dto : videoDTOList) {
            ContentEntity content = contentRepository.findById(dto.getContentId())
                .orElseThrow(() -> new IllegalArgumentException("해당 콘텐츠가 존재하지 않습니다."));

            VideoEntity video = new VideoEntity();
            video.setContent(content);
            video.setTitle(dto.getTitle());
            video.setImage(dto.getImage());
            video.setUrl(dto.getUrl());

            videoRepository.save(video);
        }
    }

    // 동영상 수정
    @Transactional
    public void updateVideos(List<VideoCreateDTO> videoDTOList) {
        for (VideoCreateDTO dto : videoDTOList) {
            VideoEntity video = videoRepository.findById(dto.getId())
                .orElseThrow(() -> new IllegalArgumentException("해당 동영상이 존재하지 않습니다."));

            video.setTitle(dto.getTitle());
            video.setImage(dto.getImage());
            video.setUrl(dto.getUrl());

            // contentId도 수정하려면 아래 라인 추가
            if (dto.getContentId() != null && !dto.getContentId().equals(video.getContent().getId())) {
                ContentEntity content = contentRepository.findById(dto.getContentId())
                    .orElseThrow(() -> new IllegalArgumentException("해당 콘텐츠가 존재하지 않습니다."));
                video.setContent(content);
            }

            videoRepository.save(video);
        }
    }

    // 콘텐츠 ID 기준으로 동영상 목록 조회
    public List<VideoCreateDTO> getVideosByContentId(Integer contentId) {
        return videoRepository.findByContentId(contentId).stream()
                .map(video -> new VideoCreateDTO(
                        video.getId(),
                        video.getContent().getId(),
                        video.getTitle(),
                        video.getImage(),
                        video.getUrl()
                ))
                .collect(Collectors.toList());
    }

    // 삭제
    @Transactional
    public void deleteVideo(Integer id) {
        videoRepository.deleteById(id);
    }
}
✅ 3. 컨트롤러에서 사용 예
@PostMapping("/admin/videos")
public ResponseEntity<Void> createVideos(@RequestBody List<VideoCreateDTO> videoDTOList) {
videoService.createVideos(videoDTOList);
return ResponseEntity.ok().build();
}
🔧 참고 사항
등록과 수정은 각각 나눌 수도 있고, 프론트에서 id 존재 여부로 판단해 하나의 엔드포인트로 처리해도 됩니다.

UI에서는 반복 입력을 위한 배열 전송 방식을 사용하게 되므로, 컨트롤러에서도 List<VideoCreateDTO>로 받는 게 좋습니다.

썸네일, 영상 링크, 제목 필드는 프론트에서 유효성 검사와 함께 null 또는 빈값 체크가 필요합니다.

필요하면 등록/수정 통합 API나 관련 예외 처리도 도와드릴 수 있어요. 추가 요청 주세요!

나의 말:
package com.example.itview_spring.Service;

import com.example.itview_spring.DTO.ContentCreateDTO;
import com.example.itview_spring.DTO.ContentDetailDTO;
import com.example.itview_spring.DTO.ContentResponseDTO;
import com.example.itview_spring.DTO.ExternalServiceDTO;
import com.example.itview_spring.DTO.GenreDTO;
import com.example.itview_spring.DTO.ImageDTO;
import com.example.itview_spring.DTO.VideoDTO;

import com.example.itview_spring.Constant.Genre;
import com.example.itview_spring.DTO.ContentCreateDTO;
import com.example.itview_spring.Entity.ContentEntity;
import com.example.itview_spring.Repository.ContentGenreRepository;
import com.example.itview_spring.Entity.ContentGenreEntity;
import com.example.itview_spring.Entity.RatingEntity;
import com.example.itview_spring.Repository.ContentGenreRepository;
import com.example.itview_spring.Repository.ContentRepository;
import com.example.itview_spring.Repository.ExternalServiceRepository;
import com.example.itview_spring.Repository.GalleryRepository;
import com.example.itview_spring.Repository.RatingRepository;
import com.example.itview_spring.Repository.UserRepository;
import com.example.itview_spring.Repository.VideoRepository;

import lombok.RequiredArgsConstructor;
import org.modelmapper.ModelMapper;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.NoSuchElementException;
import java.util.Optional;
import java.util.stream.Collectors;


@Service
@RequiredArgsConstructor
@Transactional
public class ContentService {
private final ContentRepository contentRepository;
private final ContentGenreRepository contentGenreRepository;
private final GalleryRepository galleryRepository;
private final VideoRepository videoRepository;
private final ExternalServiceRepository externalServiceRepository;
private final RatingRepository ratingRepository;
private final UserRepository userRepository;
private final ModelMapper modelMapper;

    //전체조회
    //목록(전체조회)
    //모두 읽어서 list<방금 작성한 DTO> 전달
    //public 전달할 모양 이름은 마음대로(받을것{
    //
    //     사용한 Repository.작업할 함수.var
    //     return 전달할 값;
    //}
    // public List<ProductDTO> 안알려줌() {
    // public List<ProductDTO> List() {      ex)
    /**
     * 전체 목록조회
     *
     * @param page 조회할 페이지 번호
     * @return 결과
     */

    public Page<ContentCreateDTO> getAllContents(Pageable page) {
        int currentPage = page.getPageNumber()-1;
        int pageLimits = 10 ;

        Pageable pageable = PageRequest.of(currentPage,pageLimits, Sort.by(Sort.Direction.DESC, "id"));
        Page<ContentEntity> contentEntities = contentRepository.findAll(pageable) ;
        Page<ContentCreateDTO> contentDTOS = contentEntities.map(data->modelMapper.map(
                data, ContentCreateDTO.class));
        return contentDTOS;
    }
//    public List<ContentCreateDTO> List() {
//        //읽기,수정/저장/삭제 ==>Repository
//        List<ContentEntity> contentEntities = contentRepository.findAll();
//        //Entity =있으면 밑에 DTO변환
//        List<ContentCreateDTO> contentDTOs = Arrays.asList(modelMapper.map(contentEntities, ContentCreateDTO[].class));
//        //DTO가 보이면 return DTO를지정
//        return contentDTOs;
//    }



    //상세보기,수정(개별조회)
    //주문번호를 받아서 해당하는 DTO에 전달
    //public ProductDTO 역시 안알려줌(Integer id) {
    //public ProductDTO read(Integer id) {    ex)
    public ContentCreateDTO read(Integer id) {
        //해당내용을 조회
        if (id == null) {
            throw new IllegalArgumentException("id는 null일 수 없습니다.");
        }
        Optional<ContentEntity> contentEntity = contentRepository.findById(id);
        if (contentEntity.isEmpty()) {
            throw new NoSuchElementException("해당 ID에 대한 콘텐츠를 찾을 수 없습니다: " + id);
        }
        ContentCreateDTO adminContentDTO = modelMapper.map(contentEntity.get(), ContentCreateDTO.class);
        return adminContentDTO;
    }

    //등록(저장)
    //DTO를 받아서 저장
    //public void 내맘대로 (ProductDTO productDTO) {
    //public void create (ProductDTO productDTO) {  ex)
    public ContentCreateDTO create(ContentCreateDTO dto) {
        //DTO가 이있으면 반드시 Entity 변환

        ContentEntity contentEntity = modelMapper.map(dto, ContentEntity.class);
        System.out.println("service add dto:"+dto);
        System.out.println("service add entity:"+contentEntity);

        contentRepository.save(contentEntity);
        return modelMapper.map(contentEntity, ContentCreateDTO.class);
    }

    //수정
    //주문번호와 DTO를 받아서, 주문번호로 조회해서 DTO의 내용을 저장
    // public void 수정할까(Integer orderId, ProductDTO productDTO) {
    // public void update(Integer orderId, ProductDTO productDTO) {   ex)
    public ContentCreateDTO update(Integer id, ContentCreateDTO dto) {
        //해당내용찾기
//        System.out.println("dto:"+dto);
ContentEntity contentEntity = modelMapper.map(dto, ContentEntity.class);

        if (contentEntity == null) {
            return null;
        }
//        System.out.println("entity:"+contentEntity);
//내용을 저장(@Id가 있는 변수는 저장 불가)
contentEntity.setTitle(dto.getTitle());
contentEntity.setContentType(dto.getContentType());
contentEntity.setReleaseDate(dto.getReleaseDate());
contentEntity.setPoster(dto.getPoster());
contentEntity.setNation(dto.getNation());
contentEntity.setDescription(dto.getDescription());
contentEntity.setDuration(dto.getDuration());
contentEntity.setAge(dto.getAge());
contentEntity.setCreatorName(dto.getCreatorName());
contentEntity.setChannelName(dto.getChannelName());

        contentRepository.save(contentEntity);
        return modelMapper.map(contentEntity, ContentCreateDTO .class);
    }

    //삭제
    //주문번호를 받아서 삭제
    //  public void 삭제가될까(Integer id) {
    //  public void delete(Integer id) {
//    public boolean delete(Integer id) {
//        // First delete related entries in content_genre_entity
//        if(contentRepository.existsById(id)) { //데이터가 존재하면
//            contentGenreRepository.deleteByContentId(id); // Assuming you have a method in repository for this
//
//            // Then delete the content entity
//            contentRepository.deleteById(id); //삭제
//            return true;
//        }
//        return false;
//    }


    @Transactional
    public void delete(Integer id) {
        ContentEntity content = contentRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException("콘텐츠 ID가 유효하지 않습니다. id: " + id));

        // Delete the related genres first
        contentGenreRepository.deleteByContent(content);

        // Now delete the content entity
        contentRepository.delete(content);
    }


    // 컨텐츠 상세 정보 조회
    public ContentDetailDTO getContentDetail(Integer contentId) {
        ContentDetailDTO contentDetail = new ContentDetailDTO();

        // 컨텐츠 정보 조회
        ContentResponseDTO contentResponseDTO = contentRepository.findContentWithAvgRating(contentId);
        // 컨텐츠 장르 조회
        List<GenreDTO> genres = contentGenreRepository.findByContentId(contentId);
        genres.forEach(genre -> {
            contentResponseDTO.getGenres().add(genre.getGenre().getGenreName());
        });
        contentDetail.setContentInfo(contentResponseDTO);

        // 갤러리 이미지 조회
        List<ImageDTO> images = galleryRepository.findByContentId(contentId);
        contentDetail.setGallery(images);

        // 동영상 조회
        List<VideoDTO> videos = videoRepository.findByContentId(contentId);
        contentDetail.setVideos(videos);

        // 외부 서비스 조회
        List<ExternalServiceDTO> externalServices = externalServiceRepository.findByContentId(contentId);
        contentDetail.setExternalServices(externalServices);

        return contentDetail;
    }
    //////////////////////////////////////////////////////////////////////////////////////////
    /**
     * 콘텐츠에 장르 추가
     *///
    //장르조회
    @Transactional
    public List<Genre> getGenresByContentId(Integer contentId) {
        ContentEntity content = contentRepository.findById(contentId)
                .orElseThrow(() -> new NoSuchElementException("콘텐츠 ID가 유효하지 않습니다. id: " + contentId));

        List<ContentGenreEntity> genreEntities = contentGenreRepository.findByContent(content);

        return genreEntities.stream()
                .map(ContentGenreEntity::getGenre)
                .collect(Collectors.toList());
    }

    @Transactional
    public void addGenres(Integer contentId, List<Genre> genres) {
        ContentEntity content = contentRepository.findById(contentId)
                .orElseThrow(() -> new IllegalArgumentException("콘텐츠 ID가 유효하지 않습니다. id: " + contentId));
        List<Genre> existingGenres = getGenresByContentId(contentId);

        for (Genre genre : genres) {
            if (existingGenres.contains(genre)) {
                continue; // 이미 있는 장르는 건너뜀
            }
            System.out.println(" add contentId :"+contentId);
            System.out.println(" add content :"+content);
            System.out.println(" add genre :"+genre);
            System.out.println(" -----------------");

            ContentGenreEntity contentGenre = new ContentGenreEntity();
            contentGenre.setContent(content);// ✅ null 아님
            contentGenre.setGenre(genre);  // ✅ 여기서 content가 null이면 에러 발생

            contentGenreRepository.save(contentGenre);
        }

    }

    /**
     * 콘텐츠 장르 수정 (기존 장르 모두 삭제 후, 새로 추가)
     */
    @Transactional
    public void updateGenres(Integer contentId, List<Genre> newGenres) {
        ContentEntity content = contentRepository.findById(contentId)
                .orElseThrow(() -> new IllegalArgumentException("콘텐츠 ID가 유효하지 않습니다. id: " + contentId));

        // 기존 장르 삭제
        List<Genre> oldGenres = getGenresByContentId(contentId);  // 기존 장르 가져오기
        contentGenreRepository.deleteByContent(content);  // 기존 장르 삭제

        // 새로운 장르 추가
        for (Genre genre : newGenres) {
//            System.out.println(" update contentId :"+contentId);
//            System.out.println(" update content :"+content);
//            System.out.println(" update genre :"+genre);
//            System.out.println(" -----------------");

            ContentGenreEntity contentGenre = new ContentGenreEntity();
            contentGenre.setContent(content); // 반드시 content 세팅
            contentGenre.setGenre(genre);
            contentGenreRepository.save(contentGenre); // 새로운 장르 저장
            // 로그로 이전 장르와 수정된 장르 비교 (선택사항)
            System.out.println("Old Genres: " + oldGenres);
            System.out.println("New Genres: " + newGenres);

        }
    }

    // 별점 등록
    public void rateContent(Integer userId, Integer contentId, Integer score) {

        // 기존 별점 조회
        Optional<RatingEntity> existingRating = ratingRepository.findByUserIdAndContentId(userId, contentId);

        if (existingRating.isEmpty()) {
            RatingEntity ratingEntity = new RatingEntity();
            ratingEntity.setUser(userRepository.findById(userId).get());
            ratingEntity.setContent(contentRepository.findById(contentId).get());
            ratingEntity.setScore(score);
        }
        else {
            // 기존 별점이 있는 경우 업데이트
            RatingEntity ratingEntity = existingRating.get();
            ratingEntity.setScore(score);
        }        
    }
} 내가 작성한것임content 와 장르 작성했음   수정할곳은 ?





ChatGPT의 말:
전체적으로 잘 구성된 ContentService 코드입니다. 기능이 많고 역할이 명확하게 분리되어 있으며, 특히 장르, 평점, 동영상, 외부 서비스, 상세조회까지 모두 커버하고 있어 구조적으로 완성도가 높습니다. 그러나 일부 중복, 개선, 보완 또는 오류 가능성이 있는 부분들이 존재합니다. 아래에 구체적인 수정 포인트를 안내드릴게요.

✅ 수정할 곳 요약
구분	내용	수정 권장 여부
🔁 중복 import	ContentCreateDTO, ContentGenreRepository	✅ 정리 필요
❌ 잘못된 평점 저장	rateContent()에서 저장 로직 누락	✅ 반드시 수정
🧩 update() 로직 누락	update()에서 ID 값 미세팅 → 신규 insert 위험	✅ 수정
🎯 개선 포인트	create(), update()에서 장르 등록도 함께 처리하면 더 직관적	⭐ 선택사항
🧹 코드 클린업	불필요한 주석 정리, 로그 개선	⭐ 선택사항
🛠️ 1. 중복 import 정리
// 중복된 import 제거
import com.example.itview_spring.DTO.ContentCreateDTO;
import com.example.itview_spring.Repository.ContentGenreRepository;
한 번만 import하면 됩니다.

🧨 2. rateContent() 에서 별점 저장 누락
// 문제 코드 (저장 없음)
if (existingRating.isEmpty()) {
RatingEntity ratingEntity = new RatingEntity();
ratingEntity.setUser(userRepository.findById(userId).get());
ratingEntity.setContent(contentRepository.findById(contentId).get());
ratingEntity.setScore(score);
// ❌ 저장 누락
}
✅ 수정 코드:

if (existingRating.isEmpty()) {
RatingEntity ratingEntity = new RatingEntity();
ratingEntity.setUser(userRepository.findById(userId).orElseThrow());
ratingEntity.setContent(contentRepository.findById(contentId).orElseThrow());
ratingEntity.setScore(score);
ratingRepository.save(ratingEntity); // ✅ 저장 필요
} else {
RatingEntity ratingEntity = existingRating.get();
ratingEntity.setScore(score);
ratingRepository.save(ratingEntity); // ✅ 수정 저장 필요
}
⚠️ 3. update()에서 ID 미세팅 → insert 위험
ModelMapper를 통해 ContentEntity를 새로 매핑하면서 id가 null인 경우, insert로 오인될 가능성이 있습니다.

✅ 아래와 같이 기존 entity를 직접 조회해서 수정하는 방식 추천:

public ContentCreateDTO update(Integer id, ContentCreateDTO dto) {
ContentEntity contentEntity = contentRepository.findById(id)
.orElseThrow(() -> new NoSuchElementException("해당 ID의 콘텐츠가 없습니다: " + id));

    contentEntity.setTitle(dto.getTitle());
    contentEntity.setContentType(dto.getContentType());
    contentEntity.setReleaseDate(dto.getReleaseDate());
    contentEntity.setPoster(dto.getPoster());
    contentEntity.setNation(dto.getNation());
    contentEntity.setDescription(dto.getDescription());
    contentEntity.setDuration(dto.getDuration());
    contentEntity.setAge(dto.getAge());
    contentEntity.setCreatorName(dto.getCreatorName());
    contentEntity.setChannelName(dto.getChannelName());

    contentRepository.save(contentEntity);
    return modelMapper.map(contentEntity, ContentCreateDTO.class);
}
🎯 4. create() 및 update()에서 장르도 함께 처리하는 방식 개선 (선택사항)
현재는 장르 추가는 별도 메서드로 분리되어 있으나, 프론트엔드에서 등록 시 장르도 같이 보내면, create() 내에서 addGenres()를 호출하는 것이 직관적입니다.

public ContentCreateDTO create(ContentCreateDTO dto) {
ContentEntity contentEntity = modelMapper.map(dto, ContentEntity.class);
contentRepository.save(contentEntity);

    // 장르 등록 처리
    if (dto.getGenres() != null) {
        addGenres(contentEntity.getId(), dto.getGenres());
    }

    return modelMapper.map(contentEntity, ContentCreateDTO.class);
}
update()도 동일하게 updateGenres() 호출하면 됩니다.

🧹 5. 기타 정리 포인트
주석은 실제 사용 중인 코드 외에는 제거하는 것이 가독성에 좋습니다.

System.out.println → log.info 등으로 교체 고려 (Spring Boot의 @Slf4j)

✅ 정리
항목	상태
중복 import	🔧 제거 권장
rateContent() 저장	❗ 반드시 수정 필요
update() ID 세팅	❗ 반드시 수정 필요
create/update → 장르 처리 포함	⭐ 추천 개선
주석, 로깅	⭐ 선택적으로 정리
필요하다면 이 ContentService를 기반으로 Controller, DTO, Entity, Mapper까지 통합적으로 구성 도와드릴 수 있습니다.

나의 말:
주요 자료 옆으로 주석 달아 다시  수정할곳은
ChatGPT의 말:
아래는 당신이 작성한 ContentService 코드를 기반으로 수정이 필요한 주요 부분들에 대해 인라인 주석을 달아 정리한 것입니다. 수정 포인트는 기능 보완, 오류 방지, 코드 개선을 중심으로 했습니다.

✅ 주요 수정 포인트 반영 + 인라인 주석
@Service
@RequiredArgsConstructor
@Transactional
public class ContentService {

    // 🔧 Repository 및 Mapper 주입
    private final ContentRepository contentRepository;
    private final ContentGenreRepository contentGenreRepository;
    private final GalleryRepository galleryRepository;
    private final VideoRepository videoRepository;
    private final ExternalServiceRepository externalServiceRepository;
    private final RatingRepository ratingRepository;
    private final UserRepository userRepository;
    private final ModelMapper modelMapper;

    /**
     * ✅ 전체 콘텐츠 목록 조회 (페이징 처리)
     */
    public Page<ContentCreateDTO> getAllContents(Pageable page) {
        int currentPage = page.getPageNumber() - 1;
        int pageLimits = 10;

        Pageable pageable = PageRequest.of(currentPage, pageLimits, Sort.by(Sort.Direction.DESC, "id"));
        Page<ContentEntity> contentEntities = contentRepository.findAll(pageable);

        // 📌 Entity → DTO 변환
        return contentEntities.map(data -> modelMapper.map(data, ContentCreateDTO.class));
    }

    /**
     * ✅ 콘텐츠 상세 조회 (수정용)
     */
    public ContentCreateDTO read(Integer id) {
        if (id == null) throw new IllegalArgumentException("id는 null일 수 없습니다.");
        ContentEntity contentEntity = contentRepository.findById(id)
            .orElseThrow(() -> new NoSuchElementException("해당 콘텐츠 없음: " + id));
        return modelMapper.map(contentEntity, ContentCreateDTO.class);
    }

    /**
     * ✅ 콘텐츠 등록
     * ⚠️ 장르 포함된 경우 addGenres 호출 권장
     */
    public ContentCreateDTO create(ContentCreateDTO dto) {
        ContentEntity contentEntity = modelMapper.map(dto, ContentEntity.class);
        contentRepository.save(contentEntity);

        // ⭐ 장르 포함 시 함께 저장
        if (dto.getGenres() != null && !dto.getGenres().isEmpty()) {
            addGenres(contentEntity.getId(), dto.getGenres()); // ⬅️ 추가
        }

        return modelMapper.map(contentEntity, ContentCreateDTO.class);
    }

    /**
     * ✅ 콘텐츠 수정
     * ⚠️ id로 기존 Entity 조회 → 수정 권장
     */
    public ContentCreateDTO update(Integer id, ContentCreateDTO dto) {
        ContentEntity contentEntity = contentRepository.findById(id)
            .orElseThrow(() -> new NoSuchElementException("수정할 콘텐츠 없음: " + id));

        // ✏️ 필드 직접 수정
        contentEntity.setTitle(dto.getTitle());
        contentEntity.setContentType(dto.getContentType());
        contentEntity.setReleaseDate(dto.getReleaseDate());
        contentEntity.setPoster(dto.getPoster());
        contentEntity.setNation(dto.getNation());
        contentEntity.setDescription(dto.getDescription());
        contentEntity.setDuration(dto.getDuration());
        contentEntity.setAge(dto.getAge());
        contentEntity.setCreatorName(dto.getCreatorName());
        contentEntity.setChannelName(dto.getChannelName());

        contentRepository.save(contentEntity);

        // ⭐ 장르 포함 시 수정
        if (dto.getGenres() != null) {
            updateGenres(id, dto.getGenres()); // ⬅️ 추가
        }

        return modelMapper.map(contentEntity, ContentCreateDTO.class);
    }

    /**
     * ✅ 콘텐츠 삭제 (연관 장르도 함께 삭제)
     */
    public void delete(Integer id) {
        ContentEntity content = contentRepository.findById(id)
            .orElseThrow(() -> new IllegalArgumentException("콘텐츠 ID가 유효하지 않습니다. id: " + id));

        contentGenreRepository.deleteByContent(content); // 📌 연관 장르 먼저 삭제
        contentRepository.delete(content);               // 📌 콘텐츠 삭제
    }

    /**
     * ✅ 상세 정보 구성 (Gallery, Video, 외부 링크 포함)
     */
    public ContentDetailDTO getContentDetail(Integer contentId) {
        ContentDetailDTO contentDetail = new ContentDetailDTO();

        ContentResponseDTO contentResponseDTO = contentRepository.findContentWithAvgRating(contentId);
        List<GenreDTO> genres = contentGenreRepository.findByContentId(contentId);
        genres.forEach(genre -> contentResponseDTO.getGenres().add(genre.getGenre().getGenreName()));
        contentDetail.setContentInfo(contentResponseDTO);

        contentDetail.setGallery(galleryRepository.findByContentId(contentId));
        contentDetail.setVideos(videoRepository.findByContentId(contentId));
        contentDetail.setExternalServices(externalServiceRepository.findByContentId(contentId));

        return contentDetail;
    }

    /**
     * ✅ 콘텐츠에 장르 추가
     */
    @Transactional
    public void addGenres(Integer contentId, List<Genre> genres) {
        ContentEntity content = contentRepository.findById(contentId)
            .orElseThrow(() -> new IllegalArgumentException("유효하지 않은 콘텐츠 ID: " + contentId));

        List<Genre> existingGenres = getGenresByContentId(contentId);

        for (Genre genre : genres) {
            if (!existingGenres.contains(genre)) {
                ContentGenreEntity contentGenre = new ContentGenreEntity();
                contentGenre.setContent(content);
                contentGenre.setGenre(genre);
                contentGenreRepository.save(contentGenre);
            }
        }
    }

    /**
     * ✅ 콘텐츠 장르 수정 (기존 삭제 후 다시 등록)
     */
    @Transactional
    public void updateGenres(Integer contentId, List<Genre> newGenres) {
        ContentEntity content = contentRepository.findById(contentId)
            .orElseThrow(() -> new IllegalArgumentException("콘텐츠 ID가 유효하지 않습니다. id: " + contentId));

        contentGenreRepository.deleteByContent(content);

        for (Genre genre : newGenres) {
            ContentGenreEntity contentGenre = new ContentGenreEntity();
            contentGenre.setContent(content);
            contentGenre.setGenre(genre);
            contentGenreRepository.save(contentGenre);
        }
    }

    /**
     * ✅ 콘텐츠 ID로 장르 조회
     */
    public List<Genre> getGenresByContentId(Integer contentId) {
        ContentEntity content = contentRepository.findById(contentId)
            .orElseThrow(() -> new NoSuchElementException("콘텐츠 ID가 유효하지 않습니다. id: " + contentId));

        return contentGenreRepository.findByContent(content).stream()
            .map(ContentGenreEntity::getGenre)
            .collect(Collectors.toList());
    }

    /**
     * ⚠️ 평점 등록/수정 → 저장 누락됨
     */
    public void rateContent(Integer userId, Integer contentId, Integer score) {
        Optional<RatingEntity> existingRating = ratingRepository.findByUserIdAndContentId(userId, contentId);

        if (existingRating.isEmpty()) {
            RatingEntity ratingEntity = new RatingEntity();
            ratingEntity.setUser(userRepository.findById(userId).orElseThrow());
            ratingEntity.setContent(contentRepository.findById(contentId).orElseThrow());
            ratingEntity.setScore(score);
            ratingRepository.save(ratingEntity); // ✅ 저장 추가
        } else {
            RatingEntity ratingEntity = existingRating.get();
            ratingEntity.setScore(score);
            ratingRepository.save(ratingEntity); // ✅ 수정 저장 추가
        }
    }
}
✅ 요약: 꼭 수정해야 할 항목
항목	설명	조치
rateContent() 저장 누락	별점 등록 후 저장 안 함	ratingRepository.save() 추가
update() 방식	modelMapper.map() 말고 findById()로 조회 후 수정	필수 수정
장르 처리	create()와 update()에서 장르 등록/수정 포함 필요	선택 권장
중복 import	ContentCreateDTO, ContentGenreRepository 등	제거 권장
필요하시면 위 코드에서 사용하는 DTO나 Mapper 설정도 추가로 도와드릴게요.
또한 Video 등록/수정 기능을 별도 Service로 분리할지도 고려해보시면 좋습니다.

나의 말:
Video 등록/수정 기능 위의 service 추가자료 요청
ChatGPT의 말:
좋습니다! 위에 기반하여 Video 등록/수정 기능을 위한 Service 클래스 자료를 아래에 작성해드리겠습니다.

✅ 1. 필요한 전제
이미 VideoEntity, VideoDTO, VideoRepository는 존재한다고 가정합니다.

영상은 특정 ContentEntity에 종속됨 → content_id로 연관 설정 필요.

✅ 2. VideoService 클래스 예시
package com.example.itview_spring.Service;

import com.example.itview_spring.DTO.VideoDTO;
import com.example.itview_spring.Entity.ContentEntity;
import com.example.itview_spring.Entity.VideoEntity;
import com.example.itview_spring.Repository.ContentRepository;
import com.example.itview_spring.Repository.VideoRepository;
import lombok.RequiredArgsConstructor;
import org.modelmapper.ModelMapper;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.NoSuchElementException;
import java.util.Optional;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Transactional
public class VideoService {

    private final VideoRepository videoRepository;
    private final ContentRepository contentRepository;
    private final ModelMapper modelMapper;

    /**
     * ✅ 특정 콘텐츠의 비디오 전체 목록 조회
     */
    public List<VideoDTO> getVideosByContentId(Integer contentId) {
        return videoRepository.findByContentId(contentId).stream()
                .map(video -> modelMapper.map(video, VideoDTO.class))
                .collect(Collectors.toList());
    }

    /**
     * ✅ 비디오 단건 조회
     */
    public VideoDTO getVideoById(Integer videoId) {
        VideoEntity video = videoRepository.findById(videoId)
                .orElseThrow(() -> new NoSuchElementException("해당 영상이 없습니다. ID: " + videoId));
        return modelMapper.map(video, VideoDTO.class);
    }

    /**
     * ✅ 비디오 등록
     */
    public VideoDTO createVideo(Integer contentId, VideoDTO dto) {
        ContentEntity content = contentRepository.findById(contentId)
                .orElseThrow(() -> new NoSuchElementException("해당 콘텐츠가 없습니다. ID: " + contentId));

        VideoEntity video = modelMapper.map(dto, VideoEntity.class);
        video.setContent(content); // 연관관계 설정

        videoRepository.save(video);

        return modelMapper.map(video, VideoDTO.class);
    }

    /**
     * ✅ 비디오 수정
     */
    public VideoDTO updateVideo(Integer videoId, VideoDTO dto) {
        VideoEntity video = videoRepository.findById(videoId)
                .orElseThrow(() -> new NoSuchElementException("해당 영상이 없습니다. ID: " + videoId));

        // 수정 가능한 필드만 업데이트
        video.setTitle(dto.getTitle());
        video.setImage(dto.getImage());
        video.setUrl(dto.getUrl());

        return modelMapper.map(video, VideoDTO.class);
    }

    /**
     * ✅ 비디오 삭제
     */
    public void deleteVideo(Integer videoId) {
        if (!videoRepository.existsById(videoId)) {
            throw new NoSuchElementException("삭제할 영상이 없습니다. ID: " + videoId);
        }
        videoRepository.deleteById(videoId);
    }
}
✅ 3. VideoDTO 예시 (확인용)
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class VideoDTO {
private Integer id;
private String title;
private String image;
private String url;
}
✅ 4. 추가 추천
관리자 화면에서 영상 추가 시 contentId는 필수로 포함되어야 합니다.

컨트롤러에서 @RequestParam 또는 URL 경로로 contentId를 전달하도록 설계하세요.

영상 등록/수정 시 Validation(@Valid, @NotBlank)도 고려하면 좋습니다.

필요하시면 Controller 예제, 또는 등록/수정 화면과 연결하는 API 문서도 함께 작성해드릴 수 있어요. 원하시면 말씀해주세요!

나의 말:
package com.example.itview_spring.Controller.Content;

import com.example.itview_spring.Constant.Genre;
import com.example.itview_spring.DTO.ContentCreateDTO;
import com.example.itview_spring.DTO.ContentDetailDTO;
import com.example.itview_spring.DTO.PageInfoDTO;
import com.example.itview_spring.Service.ContentService;
import com.example.itview_spring.Util.PageInfo;
import lombok.RequiredArgsConstructor;
import org.springframework.boot.web.servlet.error.ErrorController;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.web.PageableDefault;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.*;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import static org.springframework.data.jpa.domain.AbstractPersistable_.id;

@Controller
@RequiredArgsConstructor
public class ContentController {
private final ContentService contentService;
private final PageInfo pageInfo;

    // ==================== ERROR PAGE HANDLER ====================
    //    500 에러가 나더라도 커스텀 오류 페이지 추가 가능 (선택 사항)-----------------------------------
//    @Controller
//    public class CustomErrorController implements ErrorController {
//        @RequestMapping("/error")
//        public String handleError() {
//            return "error/customError"; // templates/error/customError.html
//        }
//    }
// ==================== CONTENT CRUD ==========================
// 등록 폼 이동
@GetMapping("/content/register")
public String newContent() {

        return "content/register";
    }

    // 등록 처리 후 → 장르 선택 페이지로 이동
    @PostMapping("/content/register")
    public String newContent(ContentCreateDTO contentDTO) {
        //데이터 저장처리 (Service -> Controller
        ContentCreateDTO savedContent = contentService.create(contentDTO); // 저장 후

        System.out.println(" 00 savedContent ==" + savedContent);
        return "redirect:/content/" + savedContent.getId() + "/genre";     // 장르 등록 폼으로 이동
        //   return "redirect:/content/list";
    }


    //localhost:8080/content/list 확인함(@GetMppping
    //전체강의 조회후 (list.html)로이동

    /**
     * 전체조회
     *
     * @param pageable 조회할 페이지 번호
     * @param model    결좌 전달
     * @return 페이지 이동
     */
    @GetMapping("/content/list")
    // 전체 목록 조회
    public String listContent(@PageableDefault(page = 1) Pageable pageable, Model model) {
        //모든 데이터를 조회
        //keyword  추가 ****
        Page<ContentCreateDTO> contentDTOS = contentService.getAllContents(pageable);
        model.addAttribute("contentDTOS", contentDTOS);
        //    System.out.println("contentDTO.            ==", contentDTOS);

        PageInfoDTO pageInfoDTO = pageInfo.getPageInfo(contentDTOS);
        model.addAttribute("pageInfoDTO", pageInfoDTO);
//        model.addAttribute("contentDTOS", contentDTOS);
//        model.addAttribute("pageInfoDTO", pageInfo.getPageInfo(contentDTOS));
return "content/list";
}

    // 상세 보기
// @GetMapping("/content/{id:\\d+}")
//    @GetMapping("/content/detail")
//    @GetMapping("/content/{id}/detail")
//    public String detailContent(@PathVariable("id") Integer id, Model model) {
@GetMapping("/content/detail")
public String detailContent(Integer id, Model model) {
// URL 경로 변수인 {id}를 받으려면 @PathVariable을 써야 합니다.
ContentCreateDTO contentDTO = contentService.read(id);
model.addAttribute("contentDTO", contentDTO);
System.out.println("deteil id         ===>" + id);
System.out.println("deteil contentDTO ===>" + contentDTO);
return "content/detail"; // 경로가 정확한지 확인 필요
}

//
//    @GetMapping("/content/{id:\\d+}")
//    public String detail(@RequestParam("id") Integer id, Model model) {
//        ContentDetailDTO detailDTO = contentService.getContentDetail(id);
//        model.addAttribute("contentDTO", detailDTO.getContentInfo()); // ContentResponseDTO
//        model.addAttribute("gallery", detailDTO.getGallery());
//        model.addAttribute("videos", detailDTO.getVideos());
//        model.addAttribute("externalServices", detailDTO.getExternalServices());
//        return "content/detail";
//    }

    // 수정 폼
    @GetMapping("/content/{id}/update")
    public String updateContent(@PathVariable("id") Integer id, Model model) {
        ContentCreateDTO contentDTO = contentService.read(id);
        model.addAttribute("contentDTO", contentDTO);
        return "content/update";
    }

    // 수정 처리 (→ 장르 수정 화면으로 리디렉트)
    @PostMapping("/content/{id}/update")
    public String updateContentProc(@PathVariable("id") Integer id, ContentCreateDTO contentDTO) {
//        contentService.update(id, contentDTO);
//        return "redirect:/content/list";
ContentCreateDTO savedContent = contentService.update(id, contentDTO);
System.out.println(" 22 savedContent ==" + savedContent);
return "redirect:/content/" + savedContent.getId() + "/genre";     // 장르 수정 폼으로 이동
}

    //삭제처리
    @GetMapping("/content/delete")
    public String deleteContent(@RequestParam("id") Integer id) {
        contentService.delete(id);
        return "redirect:/content/list";
    }

    // ==================== GENRE HANDLING ========================
    //콘텐츠 장르 등록/수정 페이지 {/content/{id}/genre)
    // 장르 선택/수정 폼
    @GetMapping("/content/{contentId}/genre")

    public String showGenreForm(@PathVariable Integer contentId, Model model) {
        ContentCreateDTO contentDTO = contentService.read(contentId);

        List<Genre> selectedGenres = contentService.getGenresByContentId(contentId); // 이 메서드가 Enum List 반환
        List<String> selectedGenreNames = selectedGenres.stream().map(Enum::name).toList(); // ✅ 변환

        model.addAttribute("contentId", contentId);
        model.addAttribute("allGenres", Genre.values());
//        model.addAttribute("selectedGenres", genreService.getSelectedGenreNames(contentId));  // 이미 선택된 경우 표시
//        model.addAttribute("genreTranslations", genreService.getGenreTranslations()); // 한글 이름 맵핑

        // 해당 contentId로 ContentDTO, 모든 장르 리스트, 선택된 장르 리스트, 장르 번역 등을 모델에 추가
        model.addAttribute("contentDTO", contentDTO);
        model.addAttribute("allGenres", Genre.values());
        model.addAttribute("selectedGenres", selectedGenres);

        Genre[] allGenres = Genre.values();

//        Map<String, String> genreTranslations = Map.of(
//                "ACTION", "액션",
//                "DRAMA", "드라마",
//                "ROMANCE", "로맨스",
//                "HORROR", "호러",
//                "THRILLER", "스릴러",
//                "COMEDY", "코미디",
//                "FANTASY", "판타지",
//                "ADVENTURE", "어드벤처",
//                "NATURAL_SCIENCE", "자연과학",
//                "KPOP", "K-POP",
//                "ANIMATION","애니메이션",
//                "SPORTS", "스포츠",
//                "MYSTERY", "미스터리",
//                "DOCUMENTARY", "다큐멘터리",
//                "SF", "SF",
//                "MUSIC", "음악",
//                "FAMILY", "가족",
//                "CONCERT", "공연실황",
//                "MUSICAL", "뮤지컬",
//                "BIOPIC", "전기",
//                "HISTORY", "역사",
//                "CRIME", "범죄",
//                "KIDS", "키즈",
//                "VARIETY", "예능",
//                "SITCOM", "시트콤",
//                "PERIOD", "시대극",
//                "ROMANTIC_COMEDY", "로맨틱 코미디",
//                "BL", "BL",
//                "TEENAGER", "틴에이저",
//                "DISASTER", "재난",
//                "COMICS", "만화",
//                "HUMANITIES", "인문학",
//                "ECONOMICS", "경제서",
//                "INVESTMENT", "투자서",
//                "NOVEL", "소설",
//                "ESSAY", "에세이",
//                "SELF_HELP", "자기계발",
//                "WAR", "전쟁",
//                "PLAY", "희곡",
//                "POETRY", "시",
//                "SLICE_OF_LIFE", "일상",
//                "HIP_HOP", "힙합",
//                "POP", "팝",
//                "MOVIE_SOUNDTRACK", "영화음악",
//                "TV_SOUNDTRACK", "드라마음악",
//                "BALLAD", "발라드",
//                "DANCE", "댄스",
//                "ROCK", "록",
//                "CLASSICAL", "클래식",
//                "INDIE", "인디",
//                "ELECTRONICA", "일렉트로니카",
//                "JPOP", "JPOP",
//                "RNB", "알앤비",
//                "TROT", "트로트"
//        );
Map<String, String> genreTranslations = Map.of(
"ACTION", "액션",
"DRAMA", "드라마",
"ROMANCE", "로맨스",
"HORROR", "호러",
"THRILLER", "스릴러",
"COMEDY", "코미디",
"FANTASY", "판타지",
"ADVENTURE", "어드벤처",
"NATURAL_SCIENCE", "자연과학",
"KPOP", "K-POP"

        );
        System.out.println(" get33 contentDTO ==" + contentDTO);
        System.out.println(" get33 contentId ==" + contentId);
        System.out.println(" get33 allGenres ==" + allGenres);
        System.out.println(" get33 selectedGenres ==" + selectedGenres);
        System.out.println(" get33 genreTranslations ==" + genreTranslations);
        System.out.println(" ---------------------");


        model.addAttribute("contentId", contentId);
        model.addAttribute("allGenres", allGenres);
        model.addAttribute("selectedGenres", selectedGenres);
        model.addAttribute("genreTranslations", genreTranslations);

        return "content/genreForm"; // 장르 선택 HTML
    }
    //********************************************************************************//

    //********************************************************************************//
    // 장르 저장
    @PostMapping("/content/{contentId}/genre")
    public String submitGenres(@PathVariable("contentId") Integer contentId,
                               @RequestParam(value = "genres", required = false) List<Genre> genres,
                               Model model) {
        if (contentId == null) {
            contentService.addGenres(contentId, genres != null ? genres :
                    List.of());
            genres = new ArrayList<>();
            System.out.println(" post null contentId  ==" + contentId);
            System.out.println(" post null genress    ==" + genres);
            System.out.println(" ---------------------");
        }

        System.out.println(" post44 contentId  ==" + contentId);
        System.out.println(" post44 genress    ==" + genres);
        System.out.println(" ---------------------");
//        contentService.updateGenres(contentId, genres != null ? genres :
//                List.of());

        // 장르 업데이트
        contentService.updateGenres(contentId, genres);

        // 업데이트된 내용 화면에 전달
        ContentCreateDTO contentDTO = contentService.read(contentId);
        List<Genre> selectedGenres = contentService.getGenresByContentId(contentId);
        List<String> selectedGenreNames = selectedGenres.stream().map(Enum::name).collect(Collectors.toList());
        // 모델에 필요한 데이터 다시 담기 (✅ 중요)


        Genre[] allGenres = Genre.values();
        Map<String, String> genreTranslations = Map.of(
                "ACTION", "액션",
                "DRAMA", "드라마",
                "ROMANCE", "로맨스",
                "HORROR", "호러",
                "THRILLER", "스릴러",
                "COMEDY", "코미디",
                "FANTASY", "판타지",
                "ADVENTURE", "어드벤처",
                "NATURAL_SCIENCE", "자연과학",
                "KPOP", "K-POP"
        );

        model.addAttribute("contentDTO", contentDTO);
        model.addAttribute("contentId", contentId);
        model.addAttribute("allGenres", allGenres);
        model.addAttribute("selectedGenres", selectedGenreNames);
        model.addAttribute("genreTranslations", genreTranslations);

        return "redirect:/content/" + contentId + "/genre";

    }

} 수정할곳과 주요사항 옆에 주석 작성해줘
ChatGPT의 말:
코드에 주요사항과 수정할 부분을 주석으로 달아 드릴게요.
중복 코드, 로직 위치, null 체크, 모델 데이터 세팅 부분 등 위주로 달았습니다.

package com.example.itview_spring.Controller.Content;

import com.example.itview_spring.Constant.Genre;
import com.example.itview_spring.DTO.ContentCreateDTO;
import com.example.itview_spring.DTO.ContentDetailDTO;
import com.example.itview_spring.DTO.PageInfoDTO;
import com.example.itview_spring.Service.ContentService;
import com.example.itview_spring.Util.PageInfo;
import lombok.RequiredArgsConstructor;
import org.springframework.boot.web.servlet.error.ErrorController;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.web.PageableDefault;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.*;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import static org.springframework.data.jpa.domain.AbstractPersistable_.id;

@Controller
@RequiredArgsConstructor
public class ContentController {
private final ContentService contentService;
private final PageInfo pageInfo;

    // ==================== ERROR PAGE HANDLER ====================
    // 500 에러용 커스텀 페이지 주석 처리해둠 (필요시 활성화)
    /*
    @Controller
    public class CustomErrorController implements ErrorController {
        @RequestMapping("/error")
        public String handleError() {
            return "error/customError"; // templates/error/customError.html
        }
    }
    */

    // ==================== CONTENT CRUD ==========================
    // 등록 폼 이동
    @GetMapping("/content/register")
    public String newContent() {
        return "content/register";
    }

    // 등록 처리 후 → 장르 선택 페이지로 이동
    @PostMapping("/content/register")
    public String newContent(ContentCreateDTO contentDTO) {
        // 데이터 저장 처리 (Service -> Controller)
        ContentCreateDTO savedContent = contentService.create(contentDTO); // 저장 후

        System.out.println(" 00 savedContent ==" + savedContent);
        return "redirect:/content/" + savedContent.getId() + "/genre"; // 등록 후 장르 폼 이동
        // return "redirect:/content/list"; // 리스트 이동 옵션 (현재는 장르 선택 우선)
    }


    // 전체강의 조회 후 list.html로 이동
    /**
     * 전체 콘텐츠 목록 조회
     * @param pageable 페이징 정보 (기본 페이지 1)
     * @param model 뷰에 전달할 모델
     * @return list 뷰
     */
    @GetMapping("/content/list")
    public String listContent(@PageableDefault(page = 1) Pageable pageable, Model model) {
        // 모든 데이터를 페이징 조회
        Page<ContentCreateDTO> contentDTOS = contentService.getAllContents(pageable);
        model.addAttribute("contentDTOS", contentDTOS);

        // 페이지 정보 생성 후 모델에 추가
        PageInfoDTO pageInfoDTO = pageInfo.getPageInfo(contentDTOS);
        model.addAttribute("pageInfoDTO", pageInfoDTO);

        return "content/list";
    }

    // 상세 보기 (id 파라미터로 받음, @PathVariable 대신 @RequestParam 형식)
    @GetMapping("/content/detail")
    public String detailContent(Integer id, Model model) {
        // URL 경로 변수로 받는게 일반적임(@PathVariable 추천)
        ContentCreateDTO contentDTO = contentService.read(id);
        model.addAttribute("contentDTO", contentDTO);

        System.out.println("detail id         ===>" + id);
        System.out.println("detail contentDTO ===>" + contentDTO);

        return "content/detail"; // 뷰 경로 확인 필요
    }

    // 수정 폼 이동
    @GetMapping("/content/{id}/update")
    public String updateContent(@PathVariable("id") Integer id, Model model) {
        ContentCreateDTO contentDTO = contentService.read(id);
        model.addAttribute("contentDTO", contentDTO);
        return "content/update";
    }

    // 수정 처리 (장르 수정 화면으로 리디렉트)
    @PostMapping("/content/{id}/update")
    public String updateContentProc(@PathVariable("id") Integer id, ContentCreateDTO contentDTO) {
        // Service에서 수정 처리 후 저장된 DTO 반환 받음
        ContentCreateDTO savedContent = contentService.update(id, contentDTO);
        System.out.println(" 22 savedContent ==" + savedContent);
        // 수정 후 바로 장르 수정 페이지로 이동
        return "redirect:/content/" + savedContent.getId() + "/genre";
    }

    // 삭제 처리 (id를 @RequestParam 으로 받음)
    @GetMapping("/content/delete")
    public String deleteContent(@RequestParam("id") Integer id) {
        contentService.delete(id);
        return "redirect:/content/list";
    }

    // ==================== GENRE HANDLING ========================

    // 장르 선택/수정 폼
    @GetMapping("/content/{contentId}/genre")
    public String showGenreForm(@PathVariable Integer contentId, Model model) {
        ContentCreateDTO contentDTO = contentService.read(contentId);

        List<Genre> selectedGenres = contentService.getGenresByContentId(contentId); // 선택된 장르 리스트
        List<String> selectedGenreNames = selectedGenres.stream().map(Enum::name).toList();

        // 중복된 addAttribute 제거 (allGenres 2번, contentId 2번 추가됨 → 아래쪽 하나만 유지하는게 좋음)
        model.addAttribute("contentId", contentId);
        model.addAttribute("contentDTO", contentDTO);
        model.addAttribute("allGenres", Genre.values());
        model.addAttribute("selectedGenres", selectedGenres);

        // 장르 한글명 매핑 - Map.of() 사용
        Map<String, String> genreTranslations = Map.of(
                "ACTION", "액션",
                "DRAMA", "드라마",
                "ROMANCE", "로맨스",
                "HORROR", "호러",
                "THRILLER", "스릴러",
                "COMEDY", "코미디",
                "FANTASY", "판타지",
                "ADVENTURE", "어드벤처",
                "NATURAL_SCIENCE", "자연과학",
                "KPOP", "K-POP"
        );

        // 디버깅용 출력 (필요 없으면 삭제 가능)
        System.out.println(" get33 contentDTO ==" + contentDTO);
        System.out.println(" get33 contentId ==" + contentId);
        System.out.println(" get33 allGenres ==" + Arrays.toString(Genre.values()));
        System.out.println(" get33 selectedGenres ==" + selectedGenres);
        System.out.println(" get33 genreTranslations ==" + genreTranslations);
        System.out.println(" ---------------------");

        model.addAttribute("genreTranslations", genreTranslations);

        return "content/genreForm"; // 장르 선택 화면
    }


    // 장르 저장 처리
    @PostMapping("/content/{contentId}/genre")
    public String submitGenres(@PathVariable("contentId") Integer contentId,
                               @RequestParam(value = "genres", required = false) List<Genre> genres,
                               Model model) {
        // [수정필요] contentId null 체크가 이상함 → null이면 처리 안되도록 수정 필요
        if (contentId == null) {
            // contentId가 null인데 service에 넘기고 있음 → NullPointerException 위험
            // 아래 로직은 contentId가 null일 때는 동작하지 않도록 분기 수정 필요
            contentService.addGenres(contentId, genres != null ? genres : List.of());
            genres = new ArrayList<>();
            System.out.println(" post null contentId  ==" + contentId);
            System.out.println(" post null genress    ==" + genres);
            System.out.println(" ---------------------");
        }

        // 정상 로직
        System.out.println(" post44 contentId  ==" + contentId);
        System.out.println(" post44 genress    ==" + genres);
        System.out.println(" ---------------------");

        // 장르 업데이트 서비스 호출 (null일 가능성 제거 후 호출 권장)
        contentService.updateGenres(contentId, genres);

        // 업데이트된 내용을 다시 읽어서 모델에 담음 (하지만 이 메서드는 리다이렉트하기 때문에 실제로 모델값 전달 안됨)
        ContentCreateDTO contentDTO = contentService.read(contentId);
        List<Genre> selectedGenres = contentService.getGenresByContentId(contentId);
        List<String> selectedGenreNames = selectedGenres.stream().map(Enum::name).collect(Collectors.toList());

        // 모델에 다시 담는데 → 리다이렉트 시 모델값이 유지되지 않으므로 리다이렉트 URL로만 처리하면 됨
        Genre[] allGenres = Genre.values();
        Map<String, String> genreTranslations = Map.of(
                "ACTION", "액션",
                "DRAMA", "드라마",
                "ROMANCE", "로맨스",
                "HORROR", "호러",
                "THRILLER", "스릴러",
                "COMEDY", "코미디",
                "FANTASY", "판타지",
                "ADVENTURE", "어드벤처",
                "NATURAL_SCIENCE", "자연과학",
                "KPOP", "K-POP"
        );

        model.addAttribute("contentDTO", contentDTO);
        model.addAttribute("contentId", contentId);
        model.addAttribute("allGenres", allGenres);
        model.addAttribute("selectedGenres", selectedGenreNames);
        model.addAttribute("genreTranslations", genreTranslations);

        // [권장] 여기서 리다이렉트시 모델 데이터는 의미없으므로 바로 리다이렉트만 남김
        return "redirect:/content/" + contentId + "/genre";
    }

}
주요 수정/확인 사항
중복된 model.addAttribute 제거:
showGenreForm()에서 contentId, allGenres를 두 번씩 넣는 부분 정리 권장.

contentId == null 체크 로직 수정 필요:
submitGenres()에서 contentId가 null일 때 동작하는 부분은 논리상 맞지 않음. 실제로 null이면 처리 중단 또는 400 오류 처리 추천.

submitGenres()에서 리다이렉트 시 모델값 의미 없음:
리다이렉트는 새로운 요청이므로 모델값이 유지되지 않음. 불필요한 모델 세팅은 삭제해도 무방.

detailContent()에서 @PathVariable 사용 권장:
URL 경로 변수로 id 받는 게 명확. 현재는 Integer id를 쿼리 파라미터로 받음.

genreTranslations 맵은 중복 정의:
맵을 클래스 상단 상수로 뺄지, 별도 서비스로 관리하는게 유지보수에 좋음.

디버깅용 System.out.println 제거 고려:
필요시 로깅 라이브러리 사용 권장.

필요하면 submitGenres null 처리 개선 예시나, detailContent 수정 예시도 만들어 드릴 수 있어요!

나의 말:
Map<String, String> genreTranslations = Map.of(
"ACTION", "액션",
"DRAMA", "드라마",
"ROMANCE", "로맨스",
"HORROR", "호러",
"THRILLER", "스릴러",
"COMEDY", "코미디",
"FANTASY", "판타지",
"ADVENTURE", "어드벤처",
"NATURAL_SCIENCE", "자연과학",
"KPOP", "K-POP",
"ANIMATION","애니메이션",
"SPORTS", "스포츠",
"MYSTERY", "미스터리",
"DOCUMENTARY", "다큐멘터리",
"SF", "SF",
"MUSIC", "음악",
"FAMILY", "가족",
"CONCERT", "공연실황",
"MUSICAL", "뮤지컬",
"BIOPIC", "전기",
"HISTORY", "역사",
"CRIME", "범죄",
"KIDS", "키즈",
"VARIETY", "예능",
"SITCOM", "시트콤",
"PERIOD", "시대극",
"ROMANTIC_COMEDY", "로맨틱 코미디",
"BL", "BL",
"TEENAGER", "틴에이저",
"DISASTER", "재난",
"COMICS", "만화",
"HUMANITIES", "인문학",
"ECONOMICS", "경제서",
"INVESTMENT", "투자서",
"NOVEL", "소설",
"ESSAY", "에세이",
"SELF_HELP", "자기계발",
"WAR", "전쟁",
"PLAY", "희곡",
"POETRY", "시",
"SLICE_OF_LIFE", "일상",
"HIP_HOP", "힙합",
"POP", "팝",
"MOVIE_SOUNDTRACK", "영화음악",
"TV_SOUNDTRACK", "드라마음악",
"BALLAD", "발라드",
"DANCE", "댄스",
"ROCK", "록",
"CLASSICAL", "클래식",
"INDIE", "인디",
"ELECTRONICA", "일렉트로니카",
"JPOP", "JPOP",
"RNB", "알앤비",
"TROT", "트로트");  수정할곳은
ChatGPT의 말:
이 genreTranslations Map은 장르(enum 이름)와 한글 번역을 매핑하는 역할을 하니, 주로 다음 부분에서 수정하거나 관리해야 합니다:

1. 중복 정의 문제 해결
   코드 내 여러 곳에서 동일한 genreTranslations Map을 반복 선언하고 있습니다.
   → 한 곳에서만 선언하고 재사용하도록 변경하세요.

2. 상수 또는 별도 클래스 분리 권장
   장르 번역이 많으니, 별도의 GenreTranslation 유틸 클래스 혹은 상수 클래스로 분리하는 게 유지보수에 좋습니다.

public class GenreTranslation {
public static final Map<String, String> TRANSLATIONS = Map.ofEntries(
Map.entry("ACTION", "액션"),
Map.entry("DRAMA", "드라마"),
// ... 이하 생략
);
}
그리고 Controller에서는

model.addAttribute("genreTranslations", GenreTranslation.TRANSLATIONS);
3. enum 활용 가능 여부
   Genre enum 내부에 필드로 한글명 저장해두고, getter로 꺼내는 방식도 권장

public enum Genre {
ACTION("액션"),
DRAMA("드라마"),
// ...
;

    private final String koreanName;

    Genre(String koreanName) {
        this.koreanName = koreanName;
    }

    public String getKoreanName() {
        return koreanName;
    }
}
→ 그러면 genreTranslations Map 없이도 Genre.ACTION.getKoreanName() 식으로 접근 가능해집니다.

4. 사용처별 수정 필요 위치
   showGenreForm() 메서드 내에서 Map 정의하는 부분

submitGenres() 메서드 내에서 Map 정의하는 부분
→ 위 두 곳에서 중복 제거 및 위 1~3번 내용에 따라 수정 필요

5. 기타
   Map에 없는 장르가 enum에 추가되면 누락될 위험 있음 → enum 내부 필드 관리 추천

Map.of()는 최대 10개 쌍까지만 허용 → 50개 이상은 Map.ofEntries() 사용 또는 HashMap 생성 후 put() 호출 사용 권장

요약
수정 포인트	설명
중복 제거	genreTranslations 여러 번 정의되어 있음 → 한 곳으로 통합
상수화	상수 클래스 또는 enum 필드로 한글명 관리 권장
enum 필드 추가	Genre enum에 한글명 필드 추가해서 관리하는 방법이 가장 깔끔
Map 크기 제한	Map.of 10쌍 제한에 걸림 → Map.ofEntries 등으로 변경 필요
필요하면 위 작업에 맞게 코드를 리팩토링해드릴 수도 있어요!

나의 말:
<!DOCTYPE html>
<html lang="kr"
      xmlns:th="http://www.thymeleaf.org"
      xmlns:layout="http://www.ultraq.net.nz/thymeleaf/layout"
      layout:decorate="~{layouts/mainlayout}">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
<main layout:fragment="content">
    <!--    <h1>Welcome to the Dashboard</h1>-->
    <!--    <p>This is your main content area.</p>-->

    <div class="container mt-5">
        <h2>콘텐츠 장르 등록/수정</h2>

        <!--        <form th:action="@{|/content/${contentId}/genre|}" method="post">-->
        <form th:action="@{/content/{contentId}/genre(contentId=${contentDTO.id})}" method="post">
            <!-- ✅ CSRF 토큰 추가 (Spring Security 사용하는 경우 필수) -->
            <!--            <input type="hidden" th:name="${_csrf.parameterName}" th:value="${_csrf.token}"/>-->
            <input id="id" th:value="${contentDTO.id}" value="post" hidden>
            <!--            <input type="hidden" name="_method" value="post" />-->

            <div class="mb-3">
                <label class="form-label">장르 선택</label>
                <!-- ✅ 각 장르 체크박스 반복 출력 -->
                <!--                <div>-->
                <!--                    <ul>-->
                <!--                        &lt;!&ndash; 장르 리스트 출력 &ndash;&gt;-->
                <!--                        <c:forEach var="genre" items="${allGenres}">-->
                <!--                            <li>-->
                <!--                                <input type="checkbox" id="genre_${genre}" name="genres" value="${genre}"-->
                <!--                                <c:if test="${selectedGenres.contains(genre.name)}">checked</c:if> />-->
                <!--                                <label for="genre_${genre}">${genreTranslations[genre]}</label>-->
                <!--                            </li>-->
                <!--                        </c:forEach>-->
                <!--                    </ul>-->
                <!--                </div>-->
                <div class="form-check" th:each="genre : ${allGenres}">
                    <input class="form-check-input" type="checkbox" name="genres"
                           th:id="${'genre-' + genre.name()}"
                           th:value="${genre.name()}"
                           th:checked="${selectedGenres != null and selectedGenres.contains(genre.name())}"/>

                    <label class="form-check-label"
                           th:for="${'genre-' + genre.name()}"
                           th:text="${genreTranslations[genre.name()]}">장르명</label>
                </div>


                <!--                       th:text="${genre.genreName}">장르명</label>-->

                <!-- ✅ 한글명 변환은 선택적으로 ENUM에 메서드 추가 -->
                <!--                    <label class="form-check-label"-->
                <!--                           th:for="${'genre-' + genre.name()}"-->
                <!--                              th:text="${genre.genreName}">-->
                <!--                           th:text="${#strings.equalsIgnoreCase(genre.name(), 'ACTION') ? '액션' :-->
                <!--                                      #strings.equalsIgnoreCase(genre.name(), 'ADVENTURE') ? '어드벤처' :-->
                <!--                                      #strings.equalsIgnoreCase(genre.name(), 'COMEDY') ? '코미디' :-->
                <!--                                      #strings.equalsIgnoreCase(genre.name(), 'DRAMA') ? '드라마' :-->
                <!--                                      #strings.equalsIgnoreCase(genre.name(), 'THRILLER') ? '스릴러' :-->
                <!--                                      #strings.equalsIgnoreCase(genre.name(), 'HORROR') ? '호러' :-->
                <!--                                      #strings.equalsIgnoreCase(genre.name(), 'FANTASY') ? '판타지' :-->
                <!--                                      #strings.equalsIgnoreCase(genre.name(), 'ROMANCE') ? '로맨스' :-->
                <!--                                      #strings.equalsIgnoreCase(genre.name(), 'NATURAL_SCIENCE') ? '자연과학' :-->
                <!--                                      #strings.equalsIgnoreCase(genre.name(), 'KPOP') ? 'K-POP' :-->
                <!--                                      genre.name())))))))))">-->
                <!--                            <span th:text="${genre.genreName}">장르</span>-->
                <!--                            장르명-->
                <!--                    </label>-->

            </div>

            <button type="submit" class="btn btn-primary">저장</button>
            <a th:href="@{/content/list}" class="btn btn-secondary">취소</a>
        </form>
        <!-- 수정된 후 데이터 보기 -->
        <h3>선택한 장르 </h3>
        <ul>
            <th:block th:each="genre : ${selectedGenres}">
                <li th:text="${genreTranslations[genre.name()]}"></li>
            </th:block>
        </ul>

<!--        &lt;!&ndash; 수정된 후 데이터 보기 &ndash;&gt;-->
<!--        <h3>선택된 장르</h3>-->
<!--        <ul>-->
<!--            <c:forEach var="genre" items="${selectedGenres}">-->
<!--                <li>${genre}</li>-->
<!--            </c:forEach>-->
<!--        </ul>-->
<!--        -->

    </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>

</main>
</body>
</html>


이걸 수정페이지로 넘어왔을때
체크박스 체크 되어있게 보여주고싶은데 어떡할까

ChatGPT의 말:
장르 수정 페이지로 넘어왔을 때, 기존에 선택된 장르(즉, DB에 저장된 장르 목록)가 체크박스에 자동으로 체크되어 보이도록 하고 싶다면, 현재 코드에서도 거의 다 잘 되어 있습니다. 다만, 몇 가지 주의할 점 및 확인 포인트를 알려드릴게요.

✅ 핵심 정리
현재 코드 중 체크박스 관련 부분:
<input class="form-check-input" type="checkbox" name="genres"
th:id="${'genre-' + genre.name()}"
th:value="${genre.name()}"
th:checked="${selectedGenres != null and selectedGenres.contains(genre.name())}"/>
이 표현식은 올바르게 체크 여부를 판단합니다.

✅ 다만, selectedGenres가 Genre 타입의 리스트인지, String 리스트인지 확인해야 합니다.

🔍 1. selectedGenres 타입 확인이 먼저입니다
컨트롤러에서 넘겨주는 selectedGenres의 타입이 다음 중 어느 쪽인지 확인하세요:

✅ (1) List<Genre>인 경우
model.addAttribute("selectedGenres", List<Genre>);
→ 위 코드에서는 다음처럼 체크:

th:checked="${selectedGenres.contains(genre)}"
❌ (2) List<String>인 경우 (genre.name() 사용 중이라면 이쪽일 가능성 큼)
model.addAttribute("selectedGenres", List<String>);
→ 위 코드에서는 다음처럼 체크:

th:checked="${selectedGenres.contains(genre.name())}"
현재 코드는 두 번째 방식인데 컨트롤러에서도 List<String>으로 넘기고 있는지 꼭 확인하세요:

List<Genre> selectedGenres = contentService.getGenresByContentId(contentId);
List<String> selectedGenreNames = selectedGenres.stream().map(Enum::name).toList();

model.addAttribute("selectedGenres", selectedGenreNames);
이렇게 넘기고 있다면, 지금 HTML 코드는 올바르게 동작합니다. (아래 예시 기준)

✅ 전체 체크박스 HTML 예시 (String 기반으로 작동)
<div class="form-check" th:each="genre : ${allGenres}">
    <input class="form-check-input" type="checkbox" name="genres"
           th:id="${'genre-' + genre.name()}"
           th:value="${genre.name()}"
           th:checked="${selectedGenres.contains(genre.name())}"/>

    <label class="form-check-label"
           th:for="${'genre-' + genre.name()}"
           th:text="${genreTranslations[genre.name()]}">장르명</label>
</div>
🛠 점검 체크리스트
체크항목	설명
selectedGenres가 String 리스트인가?	genre.name()과 비교하고 있으므로 꼭 확인 필요
th:checked 조건	contains(genre.name()) 또는 contains(genre)
체크박스의 value	th:value="${genre.name()}" 으로 일치해야 함
선택된 값이 잘 넘어오는가?	submitGenres() 메서드에서 잘 받고 있는지 확인
🧪 디버깅 팁
페이지 진입 시 다음을 출력해보면 체크 로직이 잘 동작하는지 확인 가능합니다:

<!-- 디버깅용 출력 -->
<p th:text="${selectedGenres}">선택된 장르 리스트</p>
✅ 결론
현재 코드는 List<String> 형태로 selectedGenres를 넘긴다면 정상적으로 체크박스가 체크됨

만약 체크가 안 보인다면:

selectedGenres가 비어 있거나

genre.name() 과 매칭이 안 되는 값일 수 있음

제대로 보이려면 selectedGenres.contains(genre.name()) 조건이 맞아야 함

필요하시면, Controller나 Service 코드를 함께 확인해서 정합성도 도와드릴 수 있어요.

나의 말:
@GetMapping("/content/{contentId}/genre")

    public String showGenreForm(@PathVariable Integer contentId, Model model) {
        ContentCreateDTO contentDTO = contentService.read(contentId);
        // 선택된 장르 리스트
        List<Genre> selectedGenres = contentService.getGenresByContentId(contentId); // 이 메서드가 Enum List 반환
        List<String> selectedGenreNames = selectedGenres.stream().map(Enum::name).toList(); // ✅ 변환

        // 중복된 addAttribute 제거


//        model.addAttribute("selectedGenres", genreService.getSelectedGenreNames(contentId));  // 이미 선택된 경우 표시
//        model.addAttribute("genreTranslations", genreService.getGenreTranslations()); // 한글 이름 맵핑

        // 해당 contentId로 ContentDTO, 모든 장르 리스트, 선택된 장르 리스트, 장르 번역 등을 모델에 추가
        model.addAttribute("contentId", contentId);
        model.addAttribute("contentDTO", contentDTO);
        model.addAttribute("allGenres", Genre.values());
        model.addAttribute("selectedGenres", selectedGenres);

        Genre[] allGenres = Genre.values();

        Map<String, String> genreTranslations = Map.of(
                "ACTION", "액션",
                "DRAMA", "드라마",
                "ROMANCE", "로맨스",
                "HORROR", "호러",
                "THRILLER", "스릴러",
                "COMEDY", "코미디",
                "FANTASY", "판타지",
                "ADVENTURE", "어드벤처",
                "NATURAL_SCIENCE", "자연과학",
                "KPOP", "K-POP");
// Map 크기 제한
//Map.of 10쌍 제한에 걸림 → Map.ofEntries 등으로 변경 필요
//                "ANIMATION","애니메이션",
//                "SPORTS", "스포츠",
//                "MYSTERY", "미스터리",
//                "DOCUMENTARY", "다큐멘터리",
//                "SF", "SF",
//                "MUSIC", "음악",
//                "FAMILY", "가족",
//                "CONCERT", "공연실황",
//                "MUSICAL", "뮤지컬",
//                "BIOPIC", "전기",
//                "HISTORY", "역사",
//                "CRIME", "범죄",
//                "KIDS", "키즈",
//                "VARIETY", "예능",
//                "SITCOM", "시트콤",
//                "PERIOD", "시대극",
//                "ROMANTIC_COMEDY", "로맨틱 코미디",
//                "BL", "BL",
//                "TEENAGER", "틴에이저",
//                "DISASTER", "재난",
//                "COMICS", "만화",
//                "HUMANITIES", "인문학",
//                "ECONOMICS", "경제서",
//                "INVESTMENT", "투자서",
//                "NOVEL", "소설",
//                "ESSAY", "에세이",
//                "SELF_HELP", "자기계발",
//                "WAR", "전쟁",
//                "PLAY", "희곡",
//                "POETRY", "시",
//                "SLICE_OF_LIFE", "일상",
//                "HIP_HOP", "힙합",
//                "POP", "팝",
//                "MOVIE_SOUNDTRACK", "영화음악",
//                "TV_SOUNDTRACK", "드라마음악",
//                "BALLAD", "발라드",
//                "DANCE", "댄스",
//                "ROCK", "록",
//                "CLASSICAL", "클래식",
//                "INDIE", "인디",
//                "ELECTRONICA", "일렉트로니카",
//                "JPOP", "JPOP",
//                "RNB", "알앤비",
//                "TROT", "트로트");

        System.out.println(" get33 contentDTO ==" + contentDTO);
        System.out.println(" get33 contentId ==" + contentId);
        System.out.println(" get33 allGenres ==" + allGenres);
        System.out.println(" get33 selectedGenres ==" + selectedGenres);
        System.out.println(" get33 genreTranslations ==" + genreTranslations);
        System.out.println(" ---------------------");


        model.addAttribute("contentId", contentId);
        model.addAttribute("allGenres", allGenres);
        model.addAttribute("selectedGenres", selectedGenres);
        model.addAttribute("genreTranslations", genreTranslations);

        return "content/genreForm"; // 장르 선택 HTML
    }
    //********************************************************************************//

    //********************************************************************************//
    // 장르 저장
    @PostMapping("/content/{contentId}/genre")
    public String submitGenres(@PathVariable("contentId") Integer contentId,
                               @RequestParam(value = "genres", required = false) List<Genre> genres,
                               Model model) {
        if (contentId == null) {
            contentService.addGenres(contentId, genres != null ? genres :
                    List.of());
            genres = new ArrayList<>();
            System.out.println(" post null contentId  ==" + contentId);
            System.out.println(" post null genress    ==" + genres);
            System.out.println(" ---------------------");
        }

        System.out.println(" post44 contentId  ==" + contentId);
        System.out.println(" post44 genress    ==" + genres);
        System.out.println(" ---------------------");
//        contentService.updateGenres(contentId, genres != null ? genres :
//                List.of());

        // 장르 업데이트
        contentService.updateGenres(contentId, genres);

        // 업데이트된 내용 화면에 전달
        ContentCreateDTO contentDTO = contentService.read(contentId);
        List<Genre> selectedGenres = contentService.getGenresByContentId(contentId);
        List<String> selectedGenreNames = selectedGenres.stream().map(Enum::name).collect(Collectors.toList());
        // 모델에 필요한 데이터 다시 담기 (✅ 중요)


        Genre[] allGenres = Genre.values();
Map<String, String> genreTranslations = Map.of(
"ACTION", "액션",
"DRAMA", "드라마",
"ROMANCE", "로맨스",
"HORROR", "호러",
"THRILLER", "스릴러",
"COMEDY", "코미디",
"FANTASY", "판타지",
"ADVENTURE", "어드벤처",
"NATURAL_SCIENCE", "자연과학",
"KPOP", "K-POP"
// Map 크기 제한
//Map.of 10쌍 제한에 걸림 → Map.ofEntries 등으로 변경 필요
"ANIMATION","애니메이션",
"SPORTS", "스포츠",
"MYSTERY", "미스터리",
"DOCUMENTARY", "다큐멘터리",
"SF", "SF",
"MUSIC", "음악",
"FAMILY", "가족",
"CONCERT", "공연실황",
"MUSICAL", "뮤지컬",
"BIOPIC", "전기",
"HISTORY", "역사",
"CRIME", "범죄",
"KIDS", "키즈",
"VARIETY", "예능",
"SITCOM", "시트콤",
"PERIOD", "시대극",
"ROMANTIC_COMEDY", "로맨틱 코미디",
"BL", "BL",
"TEENAGER", "틴에이저",
"DISASTER", "재난",
"COMICS", "만화",
"HUMANITIES", "인문학",
"ECONOMICS", "경제서",
"INVESTMENT", "투자서",
"NOVEL", "소설",
"ESSAY", "에세이",
"SELF_HELP", "자기계발",
"WAR", "전쟁",
"PLAY", "희곡",
"POETRY", "시",
"SLICE_OF_LIFE", "일상",
"HIP_HOP", "힙합",
"POP", "팝",
"MOVIE_SOUNDTRACK", "영화음악",
"TV_SOUNDTRACK", "드라마음악",
"BALLAD", "발라드",
"DANCE", "댄스",
"ROCK", "록",
"CLASSICAL", "클래식",
"INDIE", "인디",
"ELECTRONICA", "일렉트로니카",
"JPOP", "JPOP",
"RNB", "알앤비",
"TROT", "트로트");

        );

        model.addAttribute("contentDTO", contentDTO);
        model.addAttribute("contentId", contentId);
        model.addAttribute("allGenres", allGenres);
        model.addAttribute("selectedGenres", selectedGenreNames);
        model.addAttribute("genreTranslations", genreTranslations);

        return "redirect:/content/" + contentId + "/genre";

    } 수정할곳은 수정전과 후 비교해줘
ChatGPT의 말:
좋습니다. 정리해드릴게요.
지금 작성하신 코드는 장르 수정 폼 조회(GET) 과 장르 수정 저장(POST) 로직인데,
"수정된 후 체크박스가 체크되도록" 만들기 위한 로직입니다.

전체적으로 잘 구현되어 있지만, 다음과 같은 불일치 포인트 때문에 문제가 생깁니다:

✅ 핵심 문제 요약
🔴 GET 메서드에서는:
selectedGenres를 List<Genre> 타입으로 모델에 추가함

List<Genre> selectedGenres = contentService.getGenresByContentId(contentId);
model.addAttribute("selectedGenres", selectedGenres); // ⚠️ 타입: List<Genre>
🔴 POST 메서드에서는:
selectedGenres를 List<String> 타입으로 바꿔서 모델에 추가함

List<String> selectedGenreNames = selectedGenres.stream().map(Enum::name).collect(Collectors.toList());
model.addAttribute("selectedGenres", selectedGenreNames); // ⚠️ 타입: List<String>
✅ 이로 인해 생기는 문제
Thymeleaf에서 체크박스 체크 조건:

th:checked="${selectedGenres.contains(genre.name())}"
이 코드는 selectedGenres가 List<String>일 때만 작동합니다!

그런데 GET에서는 List<Genre>라서 .contains(genre.name()) → 체크 안 됨 ❌

✅ 해결 방법: 통일!
🎯 선택지 1: selectedGenres를 항상 List<String>으로 전달 (가장 간단하고 추천)
✔ GET 수정
List<Genre> selectedGenres = contentService.getGenresByContentId(contentId);
List<String> selectedGenreNames = selectedGenres.stream().map(Enum::name).toList(); // ✅ 추가

model.addAttribute("selectedGenres", selectedGenreNames); // ✅ 수정: 항상 String 리스트로
✔ POST는 이미 이렇게 되어 있으니 OK ✅
✅ 선택지 2: 템플릿에서 비교만 변경 (별로 추천하지 않음)
th:checked="${selectedGenres.contains(genre)}"
이건 selectedGenres가 List<Genre>일 때만 동작

하지만 POST에서는 다시 List<String>로 바꾸어야 하므로 코드 유지가 어렵고 혼란 유발

✅ 요약: 수정 전/후 비교
위치	수정 전	수정 후
GET	model.addAttribute("selectedGenres", selectedGenres); (→ List<Genre>)	model.addAttribute("selectedGenres", selectedGenreNames); (→ List<String>)
HTML	th:checked="${selectedGenres.contains(genre.name())}"	변경 없음 ✅
POST	이미 List<String> 로 전달 중	변경 없음 ✅
💡 추가: Map.of(...) 문제 해결
현재 아래처럼 Map.of(...)로 10개 이상 항목 정의해서 에러 발생할 수 있어요:

Map<String, String> genreTranslations = Map.of(
"ACTION", "액션",
...
"KPOP", "K-POP",
"ANIMATION", "애니메이션", // ⚠️ 11개 이상 → 런타임 예외 발생
);
✅ 수정 방법 → Map.ofEntries(...) 사용:
Map<String, String> genreTranslations = Map.ofEntries(
Map.entry("ACTION", "액션"),
Map.entry("DRAMA", "드라마"),
Map.entry("ROMANCE", "로맨스"),
Map.entry("HORROR", "호러"),
Map.entry("THRILLER", "스릴러"),
Map.entry("COMEDY", "코미디"),
Map.entry("FANTASY", "판타지"),
Map.entry("ADVENTURE", "어드벤처"),
Map.entry("NATURAL_SCIENCE", "자연과학"),
Map.entry("KPOP", "K-POP"),
Map.entry("ANIMATION", "애니메이션"),
Map.entry("SPORTS", "스포츠"),
// ... 생략
);
✅ 결론 (한 줄 요약)
selectedGenres는 항상 List<String> 형태로 모델에 넣고,

th:checked="${selectedGenres.contains(genre.name())}" 그대로 사용하세요.

필요하면 내가 수정된 GET 메서드 코드 한 번에 정리해드릴게요.

나의 말:
GET 메서드 코드 한 번에 정리
ChatGPT의 말:
좋습니다! 아래는 장르 수정 페이지(GET) 요청 시 사용하는 @GetMapping 메서드를 깔끔하게 정리한 버전입니다.

✅ 목적:
selectedGenres를 항상 List<String>으로 통일

Map.ofEntries로 번역 맵 예외 없이 정의

중복된 addAttribute 제거

✅ 수정된 @GetMapping("/content/{contentId}/genre") 전체 코드:
@GetMapping("/content/{contentId}/genre")
public String showGenreForm(@PathVariable Integer contentId, Model model) {
// 콘텐츠 정보 조회
ContentCreateDTO contentDTO = contentService.read(contentId);

    // 선택된 장르 (List<Genre>) → List<String>으로 변환
    List<Genre> selectedGenres = contentService.getGenresByContentId(contentId);
    List<String> selectedGenreNames = selectedGenres.stream()
            .map(Enum::name)
            .toList(); // ✅ 템플릿에서 체크하기 좋게

    // 장르 번역 맵 (10개 초과이므로 Map.ofEntries 사용)
    Map<String, String> genreTranslations = Map.ofEntries(
            Map.entry("ACTION", "액션"),
            Map.entry("DRAMA", "드라마"),
            Map.entry("ROMANCE", "로맨스"),
            Map.entry("HORROR", "호러"),
            Map.entry("THRILLER", "스릴러"),
            Map.entry("COMEDY", "코미디"),
            Map.entry("FANTASY", "판타지"),
            Map.entry("ADVENTURE", "어드벤처"),
            Map.entry("NATURAL_SCIENCE", "자연과학"),
            Map.entry("KPOP", "K-POP"),
            Map.entry("ANIMATION", "애니메이션"),
            Map.entry("SPORTS", "스포츠"),
            Map.entry("MYSTERY", "미스터리"),
            Map.entry("DOCUMENTARY", "다큐멘터리"),
            Map.entry("SF", "SF"),
            Map.entry("MUSIC", "음악"),
            Map.entry("FAMILY", "가족"),
            Map.entry("CONCERT", "공연실황"),
            Map.entry("MUSICAL", "뮤지컬"),
            Map.entry("BIOPIC", "전기"),
            Map.entry("HISTORY", "역사"),
            Map.entry("CRIME", "범죄"),
            Map.entry("KIDS", "키즈"),
            Map.entry("VARIETY", "예능"),
            Map.entry("SITCOM", "시트콤"),
            Map.entry("PERIOD", "시대극"),
            Map.entry("ROMANTIC_COMEDY", "로맨틱 코미디"),
            Map.entry("BL", "BL"),
            Map.entry("TEENAGER", "틴에이저"),
            Map.entry("DISASTER", "재난"),
            Map.entry("COMICS", "만화"),
            Map.entry("HUMANITIES", "인문학"),
            Map.entry("ECONOMICS", "경제서"),
            Map.entry("INVESTMENT", "투자서"),
            Map.entry("NOVEL", "소설"),
            Map.entry("ESSAY", "에세이"),
            Map.entry("SELF_HELP", "자기계발"),
            Map.entry("WAR", "전쟁"),
            Map.entry("PLAY", "희곡"),
            Map.entry("POETRY", "시"),
            Map.entry("SLICE_OF_LIFE", "일상"),
            Map.entry("HIP_HOP", "힙합"),
            Map.entry("POP", "팝"),
            Map.entry("MOVIE_SOUNDTRACK", "영화음악"),
            Map.entry("TV_SOUNDTRACK", "드라마음악"),
            Map.entry("BALLAD", "발라드"),
            Map.entry("DANCE", "댄스"),
            Map.entry("ROCK", "록"),
            Map.entry("CLASSICAL", "클래식"),
            Map.entry("INDIE", "인디"),
            Map.entry("ELECTRONICA", "일렉트로니카"),
            Map.entry("JPOP", "JPOP"),
            Map.entry("RNB", "알앤비"),
            Map.entry("TROT", "트로트")
    );

    // 모델에 필요한 데이터 전달
    model.addAttribute("contentDTO", contentDTO);
    model.addAttribute("contentId", contentId);
    model.addAttribute("allGenres", Genre.values());
    model.addAttribute("selectedGenres", selectedGenreNames); // ✅ String 리스트로!
    model.addAttribute("genreTranslations", genreTranslations);

    return "content/genreForm";
}
✅ 이렇게 하면 템플릿도 잘 작동합니다:
<input type="checkbox" name="genres"
th:value="${genre.name()}"
th:checked="${selectedGenres.contains(genre.name())}"/>
✔️ selectedGenres는 문자열 리스트이므로 genre.name()으로 비교 가능

필요하다면 POST도 동일하게 selectedGenres를 List<String>으로 유지하세요.
추가 질문 있으면 언제든지!

나의 말:
@PostMapping("/content/{contentId}/genre")
public String submitGenres(@PathVariable("contentId") Integer contentId,
@RequestParam(value = "genres", required = false) List<Genre> genres,
Model model) {
if (contentId == null) {
contentService.addGenres(contentId, genres != null ? genres :
List.of());
genres = new ArrayList<>();
System.out.println(" post null contentId  ==" + contentId);
System.out.println(" post null genress    ==" + genres);
System.out.println(" ---------------------");
}

        System.out.println(" post 44 contentId  ==" + contentId);
        System.out.println(" post 44 genress    ==" + genres);
        System.out.println(" ---------------------");
//        contentService.updateGenres(contentId, genres != null ? genres :
//                List.of());

        // 장르 업데이트
        contentService.updateGenres(contentId, genres);

        // 업데이트된 내용 화면에 전달
        ContentCreateDTO contentDTO = contentService.read(contentId);
        List<Genre> selectedGenres = contentService.getGenresByContentId(contentId);
        List<String> selectedGenreNames = selectedGenres.stream().map(Enum::name).collect(Collectors.toList());
        // 모델에 필요한 데이터 다시 담기 (✅ 중요)


        Genre[] allGenres = Genre.values();
        // 장르 번역 맵 (10개 초과이므로 Map.ofEntries 사용)
        Map<String, String> genreTranslations = Map.ofEntries(
                Map.entry("ACTION", "액션"),
                Map.entry("DRAMA", "드라마"),
                Map.entry("ROMANCE", "로맨스"),
                Map.entry("HORROR", "호러"),
                Map.entry("THRILLER", "스릴러"),
                Map.entry("COMEDY", "코미디"),
                Map.entry("FANTASY", "판타지"),
                Map.entry("ADVENTURE", "어드벤처"),
                Map.entry("NATURAL_SCIENCE", "자연과학"),
                Map.entry("KPOP", "K-POP"),
                Map.entry("ANIMATION", "애니메이션"),
                Map.entry("SPORTS", "스포츠"),
                Map.entry("MYSTERY", "미스터리"),
                Map.entry("DOCUMENTARY", "다큐멘터리"),
                Map.entry("SF", "SF"),
                Map.entry("MUSIC", "음악"),
                Map.entry("FAMILY", "가족"),
                Map.entry("CONCERT", "공연실황"),
                Map.entry("MUSICAL", "뮤지컬"),
                Map.entry("BIOPIC", "전기"),
                Map.entry("HISTORY", "역사"),
                Map.entry("CRIME", "범죄"),
                Map.entry("KIDS", "키즈"),
                Map.entry("VARIETY", "예능"),
                Map.entry("SITCOM", "시트콤"),
                Map.entry("PERIOD", "시대극"),
                Map.entry("ROMANTIC_COMEDY", "로맨틱 코미디"),
                Map.entry("BL", "BL"),
                Map.entry("TEENAGER", "틴에이저"),
                Map.entry("DISASTER", "재난"),
                Map.entry("COMICS", "만화"),
                Map.entry("HUMANITIES", "인문학"),
                Map.entry("ECONOMICS", "경제서"),
                Map.entry("INVESTMENT", "투자서"),
                Map.entry("NOVEL", "소설"),
                Map.entry("ESSAY", "에세이"),
                Map.entry("SELF_HELP", "자기계발"),
                Map.entry("WAR", "전쟁"),
                Map.entry("PLAY", "희곡"),
                Map.entry("POETRY", "시"),
                Map.entry("SLICE_OF_LIFE", "일상"),
                Map.entry("HIP_HOP", "힙합"),
                Map.entry("POP", "팝"),
                Map.entry("MOVIE_SOUNDTRACK", "영화음악"),
                Map.entry("TV_SOUNDTRACK", "드라마음악"),
                Map.entry("BALLAD", "발라드"),
                Map.entry("DANCE", "댄스"),
                Map.entry("ROCK", "록"),
                Map.entry("CLASSICAL", "클래식"),
                Map.entry("INDIE", "인디"),
                Map.entry("ELECTRONICA", "일렉트로니카"),
                Map.entry("JPOP", "JPOP"),
                Map.entry("RNB", "알앤비"),
                Map.entry("TROT", "트로트")
        );

        model.addAttribute("contentDTO", contentDTO);
        model.addAttribute("contentId", contentId);
        model.addAttribute("allGenres", allGenres);
        model.addAttribute("selectedGenres", selectedGenreNames);
        model.addAttribute("genreTranslations", genreTranslations);

        return "redirect:/content/" + contentId + "/genre";

    }  수정할곳 전과 후 비교 자료
ChatGPT의 말:
아래는 주신 @PostMapping("/content/{contentId}/genre") 메서드에 대해 **전(before)**과 **후(after)**를 비교하며 수정할 수 있는 핵심 포인트를 정리된 표와 함께 보여드릴게요.

✅ 전체적인 목적
불필요한 조건문 제거 (contentId == null)

중복 코드 제거

일관성 있게 selectedGenres → List<String> 사용

redirect 이후에 model.addAttribute 불필요하므로 제거

✅ 수정 전 vs 수정 후 비교
항목	수정 전 코드 (Before)	수정 후 코드 (After)
❌ if (contentId == null)	잘못된 조건문: 실제로는 null일 수 없고, 의미 없는 처리 (addGenres)	🔥 제거. contentId는 URL path variable이므로 null 방지됨
✅ 콘솔 로그	System.out.println()이 과도하게 사용됨	⚠️ 개발 중 디버깅엔 OK, 배포 전에는 logback/slf4j로 대체 추천
✅ 장르 업데이트	contentService.updateGenres(contentId, genres); 정상 작동	유지
❌ 모델 재셋팅 (model.add...)	redirect:/content/... 호출하면서도 model.addAttribute 다시 설정함 (반영 안됨)	🔥 제거 — redirect 후에는 model이 전달되지 않음
✅ genreTranslations	Map.of → Map.ofEntries로 이미 잘 작성됨	유지
✅ 리팩토링된 최종 코드
@PostMapping("/content/{contentId}/genre")
public String submitGenres(@PathVariable("contentId") Integer contentId,
@RequestParam(value = "genres", required = false) List<Genre> genres) {

    System.out.println("post - contentId: " + contentId);
    System.out.println("post - genres: " + genres);

    // 장르 업데이트 (null 허용, 빈 리스트 처리 포함)
    contentService.updateGenres(contentId, genres != null ? genres : List.of());

    // ✅ redirect 이후 model 사용하지 않으므로, addAttribute 생략
    return "redirect:/content/" + contentId + "/genre";
}
📌 뷰에서는 어떻게 유지됨?
redirect된 후, GET /content/{contentId}/genre가 다시 호출되므로
그 안에서 다음처럼 데이터가 새롭게 세팅됨:

model.addAttribute("selectedGenres", selectedGenreNames); // List<String>
model.addAttribute("allGenres", Genre.values());
model.addAttribute("genreTranslations", genreTranslations);
그래서 <input type="checkbox"... th:checked="${selectedGenres.contains(genre.name())}" /> 도 잘 작동합니다.

✅ 요약
개선 항목	적용 여부
contentId == null 제거	✅
중복된 addAttribute 제거 (POST 내)	✅
콘솔 로그 → logback 교체 (추천)	🟡 개발 중엔 OK
리디렉션 후 다시 GET에서 모델 처리	✅
필요하시면 Service 쪽 코드 (updateGenres, getGenresByContentId)까지도 리뷰해드릴게요.

나의 말:
리디렉션 후 다시 GET에서 모델 처리
Service 쪽 코드 (updateGenres, getGenresByContentId)까지도 수정할곳 전후 비교자료 ?
ChatGPT의 말:
좋습니다. 아래에서 리디렉션 후 GET에서 모델 처리가 왜 중요한지 요약한 뒤, 요청하신 updateGenres 와 getGenresByContentId 서비스 메서드의 수정 전/후 비교 자료를 상세히 제공하겠습니다.

✅ 왜 리디렉션 후 GET에서 모델 처리를 하는가?
🔁 POST → Redirect → GET (PRG 패턴)
폼 전송 후 redirect를 사용하면 브라우저 새로고침 시 중복 전송 방지됨.

POST에서 model.addAttribute()를 해도, redirect 후에는 반영되지 않음.

따라서, GET 핸들러에서 모델을 다시 세팅해야 함.

👉 그러므로, GET /content/{contentId}/genre에서 다음을 반드시 해줘야 함:
model.addAttribute("contentDTO", contentDTO);
model.addAttribute("allGenres", Genre.values());
model.addAttribute("selectedGenres", selectedGenres); // or List<String>
model.addAttribute("genreTranslations", genreTranslations);
✅ contentService.updateGenres(...) 수정 전/후 비교
✔ Before (수정 전)
public void updateGenres(Integer contentId, List<Genre> genres) {
// 기존 장르 다 지우고 새로 추가
contentGenreRepository.deleteByContentId(contentId);

    for (Genre genre : genres) {
        ContentGenre cg = new ContentGenre(contentId, genre);
        contentGenreRepository.save(cg);
    }
}
❌ 문제점
genres가 null일 경우 NullPointerException

기존에 genres == null이면 아무 것도 하지 않음 → 이전 장르가 남아 있음 (의도와 다름)

트랜잭션 보장 여부 불명확

✅ After (수정 후)
@Transactional
public void updateGenres(Integer contentId, List<Genre> genres) {
// 기존 장르 전부 삭제
contentGenreRepository.deleteByContentId(contentId);

    // 장르가 null이거나 비어있을 경우 그냥 리턴
    if (genres == null || genres.isEmpty()) return;

    // 새로운 장르 추가
    List<ContentGenre> newGenres = genres.stream()
            .map(genre -> new ContentGenre(contentId, genre))
            .toList();

    contentGenreRepository.saveAll(newGenres);
}
✅ 개선 사항
항목	개선 내용
null/빈 체크	null 또는 빈 리스트 방지됨
트랜잭션 처리	@Transactional으로 묶어 안전하게 처리
성능 향상	반복 저장 → saveAll() 사용
코드 간결화	stream().map() 사용
✅ contentService.getGenresByContentId(...) 수정 전/후 비교
✔ Before (수정 전)
public List<Genre> getGenresByContentId(Integer contentId) {
List<ContentGenre> contentGenres = contentGenreRepository.findByContentId(contentId);
return contentGenres.stream()
.map(ContentGenre::getGenre)
.collect(Collectors.toList());
}
⚠ 문제점
큰 문제는 없으나, 조금 더 명확하고 읽기 쉬운 방식으로 개선 가능

Collectors.toList() → Java 16+ 이상이면 .toList() 사용 가능

✅ After (수정 후)
public List<Genre> getGenresByContentId(Integer contentId) {
return contentGenreRepository.findByContentId(contentId).stream()
.map(ContentGenre::getGenre)
.toList(); // Java 16+부터 가능
}
📌 정리: 서비스 레이어 수정 요약표
메서드	수정 전 문제점	수정 후 개선 내용
updateGenres(...)	- null 체크 없음
- save 반복	- null/empty 체크
- saveAll 사용
- 트랜잭션 처리
  getGenresByContentId(...)	- 큰 문제는 없으나 코드冗長	- 간결하게 stream 정리
  ✨ 선택적 개선 제안 (보너스)
  Genre ↔ String 변환이 빈번하다면, 별도의 GenreUtils 클래스나 메서드 생성

genreTranslations 맵도 enum 내부 메서드로 이동 가능

예시:

public enum Genre {
ACTION("액션"), DRAMA("드라마"), ...;

    private final String displayName;

    Genre(String displayName) {
        this.displayName = displayName;
    }

    public String getDisplayName() {
        return displayName;
    }
}
필요하면 위와 같은 Enum 리팩토링도 전체 구조와 함께 도와드릴 수 있어요.

나의 말:
@Transactional
public void updateGenres(Integer contentId, List<Genre> newGenres) {
ContentEntity content = contentRepository.findById(contentId)
.orElseThrow(() -> new IllegalArgumentException("콘텐츠 ID가 유효하지 않습니다. id: " + contentId));

        // 기존 장르 삭제
        List<Genre> oldGenres = getGenresByContentId(contentId);  // 기존 장르 가져오기
        contentGenreRepository.deleteByContent(content);  // 기존 장르 삭제

        // 장르가 null이거나 비어있을 경우 그냥 리턴
//        if (genres == null || genres.isEmpty()) return;

        // 새로운 장르 추가
        for (Genre genre : newGenres) {
//            System.out.println(" update contentId :"+contentId);
//            System.out.println(" update content :"+content);
//            System.out.println(" update genre :"+genre);
//            System.out.println(" -----------------");

            ContentGenreEntity contentGenre = new ContentGenreEntity();
            contentGenre.setContent(content); // 반드시 content 세팅
            contentGenre.setGenre(genre);
            contentGenreRepository.save(contentGenre); // 새로운 장르 저장
            // 로그로 이전 장르와 수정된 장르 비교 (선택사항)
            System.out.println("Old Genres: " + oldGenres);
            System.out.println("New Genres: " + newGenres);

        }
//       다른 방법임
//        public void updateGenres(Integer contentId, List<Genre> genres) {
//            // 기존 장르 전부 삭제
//            contentGenreRepository.deleteByContentId(contentId);
//
//            // 장르가 null이거나 비어있을 경우 그냥 리턴
//            if (genres == null || genres.isEmpty()) return;
//
//            // 새로운 장르 추가
//            List<ContentGenre> newGenres = genres.stream()
//                    .map(genre -> new ContentGenre(contentId, genre))
//                    .toList();
//
//            contentGenreRepository.saveAll(newGenres);
//        }


    }

    /**
     * ✅ 콘텐츠 ID로 장르 조회
     */
    @Transactional
    public List<Genre> getGenresByContentId(Integer contentId) {
//        ContentEntity content = contentRepository.findById(contentId)
//                .orElseThrow(() -> new NoSuchElementException("콘텐츠 ID가 유효하지 않습니다. id: " + contentId));
//
//        List<ContentGenreEntity> genreEntities = contentGenreRepository.findByContent(content);
//
//        return genreEntities.stream()
//                .map(ContentGenreEntity::getGenre)
//                .collect(Collectors.toList()); //Java 16+ 이상이면 .toList() 사용 가능
return contentGenreRepository.findByContentId(contentId).stream()
.map(ContentGenre::getGenre)
.toList(); // Java 16+부터 가능

    }  dptj  .map(ContentGenreEntity::getGenre)  어떻게 수정해
ChatGPT의 말:
아래는 질문하신 부분에 대한 정확한 설명과 코드 수정입니다:

🔍 질문 요지 요약
return contentGenreRepository.findByContentId(contentId).stream()
.map(ContentGenre::getGenre)
.toList();
여기서 ContentGenre::getGenre를 ContentGenreEntity::getGenre로 바꾸고 싶은 경우, 이는 contentGenreRepository.findByContentId(...)가 반환하는 타입이 ContentGenreEntity일 경우에만 가능합니다.

✅ 상황 정리
1. 현재 사용하는 Entity 클래스 이름 확인
   질문 코드에서는 ContentGenreEntity를 사용하고 있음

그러나 .map(ContentGenre::getGenre)처럼 ContentGenre라는 이름도 섞여 있음
→ 아마 이전에 쓰던 클래스 이름 또는 DTO일 가능성 있음

✅ 수정 포인트
현재 사용하는 클래스가 ContentGenreEntity라면, .map() 안도 다음처럼 바꾸면 됩니다:

✔️ 변경 전 (틀릴 수 있음)
return contentGenreRepository.findByContentId(contentId).stream()
.map(ContentGenre::getGenre)
.toList();
✔️ 변경 후 (Entity 클래스명 맞춤)
return contentGenreRepository.findByContentId(contentId).stream()
.map(ContentGenreEntity::getGenre)
.toList();
🔄 정리: Entity 클래스 이름 혼동 정리
잘못된 클래스명 사용 시	올바른 클래스명 사용 시
ContentGenre::getGenre	ContentGenreEntity::getGenre
ContentGenre가 실제 존재하지 않거나 DTO면 오류 발생	ContentGenreEntity로 일치시켜야 정상 작동
🔧 Tip: 레포지토리 반환값도 일치시켜야 함
// Repository
List<ContentGenreEntity> findByContentId(Integer contentId);
이처럼 리턴 타입이 ContentGenreEntity일 경우에만 .map(ContentGenreEntity::getGenre)이 동작합니다.

필요하다면, ContentGenreEntity 클래스 정의를 보여주시면 추가로 확인해드릴 수 있어요.

나의 말:
OR 2972 --- [itview_spring] [nio-8080-exec-1] org.thymeleaf.TemplateEngine             : [THYMELEAF][http-nio-8080-exec-1] Exception processing template "content/genreForm": An error happened during template parsing (template: "class path resource [templates/content/genreForm.html]")   <!DOCTYPE html>
<html lang="kr"
      xmlns:th="http://www.thymeleaf.org"
      xmlns:layout="http://www.ultraq.net.nz/thymeleaf/layout"
      layout:decorate="~{layouts/mainlayout}">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
<main layout:fragment="content">
    <!--    <h1>Welcome to the Dashboard</h1>-->
    <!--    <p>This is your main content area.</p>-->

    <div class="container mt-5">
        <h2>콘텐츠 장르 등록/수정</h2>

        <!--        <form th:action="@{|/content/${contentId}/genre|}" method="post">-->
        <form th:action="@{/content/{contentId}/genre(contentId=${contentDTO.id})}" method="post">
            <!-- ✅ CSRF 토큰 추가 (Spring Security 사용하는 경우 필수) -->
            <!--            <input type="hidden" th:name="${_csrf.parameterName}" th:value="${_csrf.token}"/>-->
            <input id="id" th:value="${contentDTO.id}" value="post" hidden>
            <!--            <input type="hidden" name="_method" value="post" />-->

            <div class="mb-3">
                <label class="form-label">장르 선택</label>
                <!-- ✅ 각 장르 체크박스 반복 출력 -->
                <!--                <div>-->
                <!--                    <ul>-->
                <!--                        &lt;!&ndash; 장르 리스트 출력 &ndash;&gt;-->
                <!--                        <c:forEach var="genre" items="${allGenres}">-->
                <!--                            <li>-->
                <!--                                <input type="checkbox" id="genre_${genre}" name="genres" value="${genre}"-->
                <!--                                <c:if test="${selectedGenres.contains(genre.name)}">checked</c:if> />-->
                <!--                                <label for="genre_${genre}">${genreTranslations[genre]}</label>-->
                <!--                            </li>-->
                <!--                        </c:forEach>-->
                <!--                    </ul>-->
                <!--                </div>-->
                <div class="form-check" th:each="genre : ${allGenres}">
                    <input class="form-check-input" type="checkbox" name="genres"
                           th:id="${'genre-' + genre.name()}"
                           th:value="${genre.name()}"
                           th:checked="${selectedGenres != null and selectedGenres.contains(genre.name())}"/>

                    <label class="form-check-label"
                           th:for="${'genre-' + genre.name()}"
                           th:text="${genreTranslations[genre.name()]}">장르명</label>
                </div>


                <!--                       th:text="${genre.genreName}">장르명</label>-->

                <!-- ✅ 한글명 변환은 선택적으로 ENUM에 메서드 추가 -->
                <!--                    <label class="form-check-label"-->
                <!--                           th:for="${'genre-' + genre.name()}"-->
                <!--                              th:text="${genre.genreName}">-->
                <!--                           th:text="${#strings.equalsIgnoreCase(genre.name(), 'ACTION') ? '액션' :-->
                <!--                                      #strings.equalsIgnoreCase(genre.name(), 'ADVENTURE') ? '어드벤처' :-->
                <!--                                      #strings.equalsIgnoreCase(genre.name(), 'COMEDY') ? '코미디' :-->
                <!--                                      #strings.equalsIgnoreCase(genre.name(), 'DRAMA') ? '드라마' :-->
                <!--                                      #strings.equalsIgnoreCase(genre.name(), 'THRILLER') ? '스릴러' :-->
                <!--                                      #strings.equalsIgnoreCase(genre.name(), 'HORROR') ? '호러' :-->
                <!--                                      #strings.equalsIgnoreCase(genre.name(), 'FANTASY') ? '판타지' :-->
                <!--                                      #strings.equalsIgnoreCase(genre.name(), 'ROMANCE') ? '로맨스' :-->
                <!--                                      #strings.equalsIgnoreCase(genre.name(), 'NATURAL_SCIENCE') ? '자연과학' :-->
                <!--                                      #strings.equalsIgnoreCase(genre.name(), 'KPOP') ? 'K-POP' :-->
                <!--                                      genre.name())))))))))">-->
                <!--                            <span th:text="${genre.genreName}">장르</span>-->
                <!--                            장르명-->
                <!--                    </label>-->

            </div>

            <button type="submit" class="btn btn-primary">저장</button>
            <a th:href="@{/content/list}" class="btn btn-secondary">취소</a>
        </form>
        <!-- 수정된 후 데이터 보기 -->
        <h3>선택한 장르 </h3>
        <ul>
            <th:block th:each="genre : ${selectedGenres}">
                <li th:text="${genreTranslations[genre.name()]}"></li>
            </th:block>
        </ul>

<!--        &lt;!&ndash; 수정된 후 데이터 보기 &ndash;&gt;-->
<!--        <h3>선택된 장르</h3>-->
<!--        <ul>-->
<!--            <c:forEach var="genre" items="${selectedGenres}">-->
<!--                <li>${genre}</li>-->
<!--            </c:forEach>-->
<!--        </ul>-->
<!--        -->

    </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>

</main>
</body>
</html> 수정할곳은  
ChatGPT의 말:
Thymeleaf 템플릿에서 다음과 같은 에러 로그가 발생했을 때:

Exception processing template "content/genreForm": An error happened during template parsing
이 경우는 대부분 문법 오류나 Model에서 누락된 속성 접근, 또는 Thymeleaf에서 처리할 수 없는 표현식이 원인입니다.

🔍 주요 원인 추정
✅ 문제 핵심 의심 지점:
<li th:text="${genreTranslations[genre.name()]}"></li>
위 표현에서 genre는 String인데 .name()을 호출하려고 하면 오류가 발생합니다.

🎯 실제 문제 정리
<th:block th:each="genre : ${selectedGenres}">
<li th:text="${genreTranslations[genre.name()]}"></li>
</th:block>
여기서 selectedGenres의 타입이 List<String>이라면,
genre.name()은 불가능하고 단순히 genre를 써야 합니다.

✅ 수정 코드
<th:block th:each="genre : ${selectedGenres}">
<li th:text="${genreTranslations[genre]}">장르명</li>
</th:block>
🔧 설명
genre가 Enum이면 genre.name() 필요

genre가 String이면 genre.name() 없이 바로 사용

📌 추가로 확인할 사항
Controller에서 넣은 selectedGenres 타입을 확인
List<Genre>인지 List<String>인지에 따라 .name() 사용 여부가 달라짐

model.addAttribute("selectedGenres", selectedGenres); // List<Genre>
또는

List<String> selectedGenreNames = selectedGenres.stream().map(Enum::name).toList();
model.addAttribute("selectedGenres", selectedGenreNames); // List<String>
allGenres 반복 부분은 문제 없음
아래 부분은 Enum 기반이라 .name() 사용이 맞습니다:

<div class="form-check" th:each="genre : ${allGenres}">
    <input class="form-check-input" type="checkbox" name="genres"
           th:id="${'genre-' + genre.name()}"
           th:value="${genre.name()}"
           th:checked="${selectedGenres != null and selectedGenres.contains(genre.name())}"/>

    <label class="form-check-label"
           th:for="${'genre-' + genre.name()}"
           th:text="${genreTranslations[genre.name()]}">장르명</label>
</div>
✅ 요약: 수정할 부분
🔧 수정 전
<li th:text="${genreTranslations[genre.name()]}"></li>
🔧 수정 후
<li th:text="${genreTranslations[genre]}"></li>
✔ 위 수정으로 파싱 에러 해결됩니다.

필요하면 Controller 쪽 selectedGenres 타입도 같이 확인해 드릴게요.

나의 말:
package com.example.itview_spring.Controller.Content;

import com.example.itview_spring.Constant.Genre;
import com.example.itview_spring.DTO.ContentCreateDTO;
import com.example.itview_spring.DTO.ContentDetailDTO;
import com.example.itview_spring.DTO.PageInfoDTO;
import com.example.itview_spring.Service.ContentService;
import com.example.itview_spring.Util.PageInfo;
import lombok.RequiredArgsConstructor;
import org.springframework.boot.web.servlet.error.ErrorController;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.web.PageableDefault;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.*;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import static org.springframework.data.jpa.domain.AbstractPersistable_.id;

@Controller
@RequiredArgsConstructor
public class ContentController {
private final ContentService contentService;
private final PageInfo pageInfo;

    // ==================== ERROR PAGE HANDLER ====================
    //    500 에러가 나더라도 커스텀 오류 페이지 추가 가능 (선택 사항)-----------------------------------
//    @Controller
//    public class CustomErrorController implements ErrorController {
//        @RequestMapping("/error")
//        public String handleError() {
//            return "error/customError"; // templates/error/customError.html
//        }
//    }
// ==================== CONTENT CRUD ==========================
// 등록 폼 이동
@GetMapping("/content/register")
public String newContent() {

        return "content/register";
    }

    // 등록 처리 후 → 장르 선택 페이지로 이동
    @PostMapping("/content/register")
    public String newContent(ContentCreateDTO contentDTO) {
        //데이터 저장처리 (Service -> Controller
        ContentCreateDTO savedContent = contentService.create(contentDTO); // 저장 후

        System.out.println(" 00 savedContent ==" + savedContent);
        return "redirect:/content/" + savedContent.getId() + "/genre";     // 장르 등록 폼으로 이동
        //   return "redirect:/content/list";  // 리스트 이동 옵션 (현재는 장르 선택 우선)
    }


    //localhost:8080/content/list 확인함(@GetMppping
    //전체강의 조회후 (list.html)로이동

    /**
     * 전체조회
     *
     * @param pageable 조회할 페이지 번호 /페이징 정보 (기본 페이지 1)
     * @param model    결좌 전달 /뷰에 전달할 모델
     * @return 페이지 이동 /뷰
     */
    @GetMapping("/content/list")
    // 전체 목록 조회
    public String listContent(@PageableDefault(page = 1) Pageable pageable, Model model) {
        //모든 데이터를 조회
        //keyword  추가 ****
        Page<ContentCreateDTO> contentDTOS = contentService.getAllContents(pageable);
        model.addAttribute("contentDTOS", contentDTOS);
        //    System.out.println("contentDTO.            ==", contentDTOS);

        // 페이지 정보 생성 후 모델에 추가
        PageInfoDTO pageInfoDTO = pageInfo.getPageInfo(contentDTOS);
        model.addAttribute("pageInfoDTO", pageInfoDTO);
//        model.addAttribute("contentDTOS", contentDTOS);
//        model.addAttribute("pageInfoDTO", pageInfo.getPageInfo(contentDTOS));
return "content/list";
}

    // 상세 보기 (id 파라미터로 받음, @PathVariable 대신 @RequestParam 형식)
// @GetMapping("/content/{id:\\d+}")
//    @GetMapping("/content/detail")
//    @GetMapping("/content/{id}/detail")
//    public String detailContent(@PathVariable("id") Integer id, Model model) {
@GetMapping("/content/detail")
public String detailContent(Integer id, Model model) {
// URL 경로 변수인 {id}를 받으려면 @PathVariable을 써야 합니다.
ContentCreateDTO contentDTO = contentService.read(id);
model.addAttribute("contentDTO", contentDTO);
System.out.println("deteil id         ===>" + id);
System.out.println("deteil contentDTO ===>" + contentDTO);
return "content/detail"; // 경로가 정확한지 확인 필요
}

//
//    @GetMapping("/content/{id:\\d+}")
//    public String detail(@RequestParam("id") Integer id, Model model) {
//        ContentDetailDTO detailDTO = contentService.getContentDetail(id);
//        model.addAttribute("contentDTO", detailDTO.getContentInfo()); // ContentResponseDTO
//        model.addAttribute("gallery", detailDTO.getGallery());
//        model.addAttribute("videos", detailDTO.getVideos());
//        model.addAttribute("externalServices", detailDTO.getExternalServices());
//        return "content/detail";
//    }

    // 수정 폼 이동
    @GetMapping("/content/{id}/update")
    public String updateContent(@PathVariable("id") Integer id, Model model) {
        ContentCreateDTO contentDTO = contentService.read(id);
        model.addAttribute("contentDTO", contentDTO);
        return "content/update";
    }

    // 수정 처리 (→ 장르 수정 화면으로 리디렉트)
    @PostMapping("/content/{id}/update")
    public String updateContentProc(@PathVariable("id") Integer id, ContentCreateDTO contentDTO) {
//        contentService.update(id, contentDTO);
//        return "redirect:/content/list";
// Service에서 수정 처리 후 저장된 DTO 반환 받음
ContentCreateDTO savedContent = contentService.update(id, contentDTO);
//        System.out.println(" 22 savedContent ==" + savedContent);
// 수정 후 바로 장르 수정 페이지로 이동
return "redirect:/content/" + savedContent.getId() + "/genre";     // 장르 수정 폼으로 이동
}

    // 삭제 처리 (id를 @RequestParam 으로 받음)
    @GetMapping("/content/delete")
    public String deleteContent(@RequestParam("id") Integer id) {
        contentService.delete(id);
        return "redirect:/content/list";
    }

    // ==================== GENRE HANDLING ========================
    //콘텐츠 장르 등록/수정 페이지 {/content/{id}/genre)
    // 장르 선택/수정 폼
    @GetMapping("/content/{contentId}/genre")

    public String showGenreForm(@PathVariable Integer contentId, Model model) {
        ContentCreateDTO contentDTO = contentService.read(contentId);
        // 선택된 장르 (List<Genre>) → List<String>으로 변환
        List<Genre> selectedGenres = contentService.getGenresByContentId(contentId); // 이 메서드가 Enum List 반환
        List<String> selectedGenreNames = selectedGenres.stream()
                .map(Enum::name)
                .toList(); // ⚠️ 타입: List<Genre>// ✅ 템플릿에서 체크하기 좋게
        model.addAttribute("selectedGenres", selectedGenres); // ⚠️ 타입: List<Genre>
        model.addAttribute("selectedGenres", selectedGenreNames); // ✅ 수정: 항상 String 리스트로
        // 중복된 addAttribute 제거

//        model.addAttribute("selectedGenres", genreService.getSelectedGenreNames(contentId));  // 이미 선택된 경우 표시
//        model.addAttribute("genreTranslations", genreService.getGenreTranslations()); // 한글 이름 맵핑


        Genre[] allGenres = Genre.values();
        // 장르 번역 맵 (10개 초과이므로 Map.ofEntries 사용)
        Map<String, String> genreTranslations = Map.ofEntries(
                Map.entry("ACTION", "액션"),
                Map.entry("DRAMA", "드라마"),
                Map.entry("ROMANCE", "로맨스"),
                Map.entry("HORROR", "호러"),
                Map.entry("THRILLER", "스릴러"),
                Map.entry("COMEDY", "코미디"),
                Map.entry("FANTASY", "판타지"),
                Map.entry("ADVENTURE", "어드벤처"),
                Map.entry("NATURAL_SCIENCE", "자연과학"),
                Map.entry("KPOP", "K-POP"),
                Map.entry("ANIMATION", "애니메이션"),
                Map.entry("SPORTS", "스포츠"),
                Map.entry("MYSTERY", "미스터리"),
                Map.entry("DOCUMENTARY", "다큐멘터리"),
                Map.entry("SF", "SF"),
                Map.entry("MUSIC", "음악"),
                Map.entry("FAMILY", "가족"),
                Map.entry("CONCERT", "공연실황"),
                Map.entry("MUSICAL", "뮤지컬"),
                Map.entry("BIOPIC", "전기"),
                Map.entry("HISTORY", "역사"),
                Map.entry("CRIME", "범죄"),
                Map.entry("KIDS", "키즈"),
                Map.entry("VARIETY", "예능"),
                Map.entry("SITCOM", "시트콤"),
                Map.entry("PERIOD", "시대극"),
                Map.entry("ROMANTIC_COMEDY", "로맨틱 코미디"),
                Map.entry("BL", "BL"),
                Map.entry("TEENAGER", "틴에이저"),
                Map.entry("DISASTER", "재난"),
                Map.entry("COMICS", "만화"),
                Map.entry("HUMANITIES", "인문학"),
                Map.entry("ECONOMICS", "경제서"),
                Map.entry("INVESTMENT", "투자서"),
                Map.entry("NOVEL", "소설"),
                Map.entry("ESSAY", "에세이"),
                Map.entry("SELF_HELP", "자기계발"),
                Map.entry("WAR", "전쟁"),
                Map.entry("PLAY", "희곡"),
                Map.entry("POETRY", "시"),
                Map.entry("SLICE_OF_LIFE", "일상"),
                Map.entry("HIP_HOP", "힙합"),
                Map.entry("POP", "팝"),
                Map.entry("MOVIE_SOUNDTRACK", "영화음악"),
                Map.entry("TV_SOUNDTRACK", "드라마음악"),
                Map.entry("BALLAD", "발라드"),
                Map.entry("DANCE", "댄스"),
                Map.entry("ROCK", "록"),
                Map.entry("CLASSICAL", "클래식"),
                Map.entry("INDIE", "인디"),
                Map.entry("ELECTRONICA", "일렉트로니카"),
                Map.entry("JPOP", "JPOP"),
                Map.entry("RNB", "알앤비"),
                Map.entry("TROT", "트로트")
        );

        // 해당 contentId로 ContentDTO, 모든 장르 리스트, 선택된 장르 리스트, 장르 번역 등을 모델에 추가
        // 모델에 필요한 데이터 전달
        model.addAttribute("contentDTO", contentDTO);
        model.addAttribute("contentId", contentId);
        model.addAttribute("allGenres", Genre.values());
        model.addAttribute("selectedGenres", selectedGenreNames); // ✅ String 리스트로!
        model.addAttribute("genreTranslations", genreTranslations);


        System.out.println(" get33 contentDTO ==" + contentDTO);
        System.out.println(" get33 contentId ==" + contentId);
        System.out.println(" get33 allGenres ==" + allGenres);
        System.out.println(" get33 selectedGenres ==" + selectedGenres);
        System.out.println(" get33 genreTranslations ==" + genreTranslations);
        System.out.println(" ---------------------");

        return "content/genreForm"; // 장르 선택 HTML
    }
    //********************************************************************************//

    //********************************************************************************//
    // 장르 저장
    @PostMapping("/content/{contentId}/genre")
    public String submitGenres(@PathVariable("contentId") Integer contentId,
                               @RequestParam(value = "genres", required = false) List<Genre> genres,
                               Model model) {

        System.out.println(" post 44 contentId  ==" + contentId);
        System.out.println(" post 44 genress    ==" + genres);
        System.out.println(" ---------------------");
//        contentService.updateGenres(contentId, genres != null ? genres :
//                List.of());

        // 장르 업데이트 (null 허용, 빈 리스트 처리 포함)
        contentService.updateGenres(contentId, genres != null ? genres : List.of());

        // 업데이트된 내용 화면에 전달
        ContentCreateDTO contentDTO = contentService.read(contentId);
        List<Genre> selectedGenres = contentService.getGenresByContentId(contentId);
        List<String> selectedGenreNames = selectedGenres.stream().map(Enum::name).collect(Collectors.toList());
        // 모델에 필요한 데이터 다시 담기 (✅ 중요)
        // ✅ redirect 이후 model 사용하지 않으므로, addAttribute 생략

        Genre[] allGenres = Genre.values();
        // 장르 번역 맵 (10개 초과이므로 Map.ofEntries 사용)
        Map<String, String> genreTranslations = Map.ofEntries(
                Map.entry("ACTION", "액션"),
                Map.entry("DRAMA", "드라마"),
                Map.entry("ROMANCE", "로맨스"),
                Map.entry("HORROR", "호러"),
                Map.entry("THRILLER", "스릴러"),
                Map.entry("COMEDY", "코미디"),
                Map.entry("FANTASY", "판타지"),
                Map.entry("ADVENTURE", "어드벤처"),
                Map.entry("NATURAL_SCIENCE", "자연과학"),
                Map.entry("KPOP", "K-POP"),
                Map.entry("ANIMATION", "애니메이션"),
                Map.entry("SPORTS", "스포츠"),
                Map.entry("MYSTERY", "미스터리"),
                Map.entry("DOCUMENTARY", "다큐멘터리"),
                Map.entry("SF", "SF"),
                Map.entry("MUSIC", "음악"),
                Map.entry("FAMILY", "가족"),
                Map.entry("CONCERT", "공연실황"),
                Map.entry("MUSICAL", "뮤지컬"),
                Map.entry("BIOPIC", "전기"),
                Map.entry("HISTORY", "역사"),
                Map.entry("CRIME", "범죄"),
                Map.entry("KIDS", "키즈"),
                Map.entry("VARIETY", "예능"),
                Map.entry("SITCOM", "시트콤"),
                Map.entry("PERIOD", "시대극"),
                Map.entry("ROMANTIC_COMEDY", "로맨틱 코미디"),
                Map.entry("BL", "BL"),
                Map.entry("TEENAGER", "틴에이저"),
                Map.entry("DISASTER", "재난"),
                Map.entry("COMICS", "만화"),
                Map.entry("HUMANITIES", "인문학"),
                Map.entry("ECONOMICS", "경제서"),
                Map.entry("INVESTMENT", "투자서"),
                Map.entry("NOVEL", "소설"),
                Map.entry("ESSAY", "에세이"),
                Map.entry("SELF_HELP", "자기계발"),
                Map.entry("WAR", "전쟁"),
                Map.entry("PLAY", "희곡"),
                Map.entry("POETRY", "시"),
                Map.entry("SLICE_OF_LIFE", "일상"),
                Map.entry("HIP_HOP", "힙합"),
                Map.entry("POP", "팝"),
                Map.entry("MOVIE_SOUNDTRACK", "영화음악"),
                Map.entry("TV_SOUNDTRACK", "드라마음악"),
                Map.entry("BALLAD", "발라드"),
                Map.entry("DANCE", "댄스"),
                Map.entry("ROCK", "록"),
                Map.entry("CLASSICAL", "클래식"),
                Map.entry("INDIE", "인디"),
                Map.entry("ELECTRONICA", "일렉트로니카"),
                Map.entry("JPOP", "JPOP"),
                Map.entry("RNB", "알앤비"),
                Map.entry("TROT", "트로트")
        );

//        model.addAttribute("contentDTO", contentDTO);
//        model.addAttribute("contentId", contentId);
//        model.addAttribute("allGenres", allGenres);
//        model.addAttribute("selectedGenres", selectedGenreNames);// List<String>
//        model.addAttribute("genreTranslations", genreTranslations);

        model.addAttribute("contentDTO", contentDTO);
        model.addAttribute("selectedGenres", selectedGenreNames); // List<String>
        model.addAttribute("allGenres", Genre.values());
        model.addAttribute("genreTranslations", genreTranslations);

        return "redirect:/content/" + contentId + "/genre";

    }

}  cotroller 과 html 수정할곳과 수정전과 후 비교출력
ChatGPT의 말:
좋습니다! 현재 요청은 다음과 같습니다:

🎯 "Controller와 HTML에서 수정할 부분과 수정 전후 비교를 정리해달라"
즉, Thymeleaf 렌더링 오류, 데이터 전달 방식 문제, 중복 model.addAttribute 제거, 그리고 템플릿 코드 정리 등을 포함한 정리입니다.

✅ 전체 목적
🔁 POST → 리디렉션 → GET 패턴 정리 (PRG)

🧹 Model 전달 중복 제거

✅ List<Genre> vs List<String> 불일치 해결

🛠️ HTML 내 genre.name() 호출 오류 수정

1️⃣ Controller – 수정 전 vs 후
🔧 문제 코드: @GetMapping("/content/{contentId}/genre")
(중복된 model, 혼란을 주는 데이터 타입)

✖️ 수정 전
model.addAttribute("selectedGenres", selectedGenres); // List<Genre>
model.addAttribute("selectedGenres", selectedGenreNames); // List<String> (덮어씀)
✅ 수정 후
// 중복 제거, String 타입만 사용
List<String> selectedGenreNames = selectedGenres.stream()
.map(Enum::name)
.toList();
model.addAttribute("selectedGenres", selectedGenreNames); // ✅ 템플릿에서는 name 기반으로 체크
🔧 문제 코드: @PostMapping("/content/{contentId}/genre")
✖️ 수정 전
model.addAttribute("contentDTO", contentDTO);
model.addAttribute("selectedGenres", selectedGenreNames);
model.addAttribute("allGenres", Genre.values());
model.addAttribute("genreTranslations", genreTranslations);
return "redirect:/content/" + contentId + "/genre";
❌ redirect: 후 model.addAttribute()는 무의미함

❌ 결국 GET 요청으로 이동되므로, model 데이터는 사라짐

✅ 수정 후
// 🔥 리디렉션에서는 model 사용 안함 — 제거
return "redirect:/content/" + contentId + "/genre";
2️⃣ HTML (Thymeleaf) 수정
🔧 문제 1: 선택된 장르 표시 파트
✖️ 수정 전
<ul>
    <th:block th:each="genre : ${selectedGenres}">
        <li th:text="${genreTranslations[genre.name()]}"></li>
    </th:block>
</ul>
❌ selectedGenres가 List<String>이면 genre.name() 호출 불가 → 오류 발생

✅ 수정 후
<ul>
    <th:block th:each="genre : ${selectedGenres}">
        <li th:text="${genreTranslations[genre]}"></li>
    </th:block>
</ul>
🔧 문제 2: 장르 체크박스 파트
✅ 기존 구조 (좋음)
<div class="form-check" th:each="genre : ${allGenres}">
    <input class="form-check-input" type="checkbox" name="genres"
           th:id="${'genre-' + genre.name()}"
           th:value="${genre.name()}"
           th:checked="${selectedGenres != null and selectedGenres.contains(genre.name())}" />

    <label class="form-check-label"
           th:for="${'genre-' + genre.name()}"
           th:text="${genreTranslations[genre.name()]}">장르명</label>
</div>
✅ genre는 Enum → .name() 사용 적절

✅ selectedGenres는 List<String> → contains(genre.name()) 가능

✅ genreTranslations도 Map<String, String>이라 key로 사용 가능

🔧 별도 수정 필요 없음

✅ 수정 전 vs 후 요약 비교
위치	수정 전	수정 후
Controller model.addAttribute	selectedGenres 두 번 설정 (List<Genre> & List<String>)	List<String> 하나로 통일
POST 후 redirect에서 model.addAttribute()	사용됨 (불필요)	제거
HTML 장르 출력 (genre.name())	genre.name() 사용 (List<String>일 때 오류)	genre만 사용
HTML 장르 체크박스	문제 없음	유지
✨ 최종 체크리스트
항목	상태
✅ Controller에서 중복된 모델 속성 제거	완료
✅ redirect 이후 model.addAttribute 제거	완료
✅ selectedGenres 타입 일관성 유지 (List<String>)	완료
✅ Thymeleaf .name() 문제 수정	완료
✅ 장르 체크박스와 출력 일관성 유지	완료
필요하다면 전체 코드 정리된 버전도 제공할 수 있어요.
원하시면 말씀 주세요!

나의 말:
원인: org.hibernate.exception.DataException: 명령문을 실행할 수 없습니다. [열 "('ACTION', 'ADVENTURE', 'COMEDY', 'DRAMA', 'FANTASY', 'HORROR', 'KPOP', 'NATURAL_SCIENCE', 'ROMANCE', 'THRILLER')"에 허용되지 않는 값: "ANIMATION"; SQL 명령문:
content_genre_entity(content_id,genre,id)에 값을 삽입합니다(?,?,default) [22030-232]] [content_genre_entity(content_id,genre,id)에 값을 삽입합니다(?,?,default)]
org.hibernate.exception.internal.SQLExceptionTypeDelegate.convert(SQLExceptionTypeDelegate.java:55)에서 수정할 package com.example.itview_spring.Controller.Content;

import com.example.itview_spring.Constant.Genre;
import com.example.itview_spring.DTO.ContentCreateDTO;
import com.example.itview_spring.DTO.ContentDetailDTO;
import com.example.itview_spring.DTO.PageInfoDTO;
import com.example.itview_spring.Service.ContentService;
import com.example.itview_spring.Util.PageInfo;
import lombok.RequiredArgsConstructor;
import org.springframework.boot.web.servlet.error.ErrorController;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.web.PageableDefault;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.*;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import static org.springframework.data.jpa.domain.AbstractPersistable_.id;

@Controller
@RequiredArgsConstructor
public class ContentController {
private final ContentService contentService;
private final PageInfo pageInfo;

    // ==================== ERROR PAGE HANDLER ====================
    //    500 에러가 나더라도 커스텀 오류 페이지 추가 가능 (선택 사항)-----------------------------------
//    @Controller
//    public class CustomErrorController implements ErrorController {
//        @RequestMapping("/error")
//        public String handleError() {
//            return "error/customError"; // templates/error/customError.html
//        }
//    }
// ==================== CONTENT CRUD ==========================
// 등록 폼 이동
@GetMapping("/content/register")
public String newContent() {

        return "content/register";
    }

    // 등록 처리 후 → 장르 선택 페이지로 이동
    @PostMapping("/content/register")
    public String newContent(ContentCreateDTO contentDTO) {
        //데이터 저장처리 (Service -> Controller
        ContentCreateDTO savedContent = contentService.create(contentDTO); // 저장 후

        System.out.println(" 00 savedContent ==" + savedContent);
        return "redirect:/content/" + savedContent.getId() + "/genre";     // 장르 등록 폼으로 이동
        //   return "redirect:/content/list";  // 리스트 이동 옵션 (현재는 장르 선택 우선)
    }


    //localhost:8080/content/list 확인함(@GetMppping
    //전체강의 조회후 (list.html)로이동

    /**
     * 전체조회
     *
     * @param pageable 조회할 페이지 번호 /페이징 정보 (기본 페이지 1)
     * @param model    결좌 전달 /뷰에 전달할 모델
     * @return 페이지 이동 /뷰
     */
    @GetMapping("/content/list")
    // 전체 목록 조회
    public String listContent(@PageableDefault(page = 1) Pageable pageable, Model model) {
        //모든 데이터를 조회
        //keyword  추가 ****
        Page<ContentCreateDTO> contentDTOS = contentService.getAllContents(pageable);
        model.addAttribute("contentDTOS", contentDTOS);
        //    System.out.println("contentDTO.            ==", contentDTOS);

        // 페이지 정보 생성 후 모델에 추가
        PageInfoDTO pageInfoDTO = pageInfo.getPageInfo(contentDTOS);
        model.addAttribute("pageInfoDTO", pageInfoDTO);
//        model.addAttribute("contentDTOS", contentDTOS);
//        model.addAttribute("pageInfoDTO", pageInfo.getPageInfo(contentDTOS));
return "content/list";
}

    // 상세 보기 (id 파라미터로 받음, @PathVariable 대신 @RequestParam 형식)
// @GetMapping("/content/{id:\\d+}")
//    @GetMapping("/content/detail")
//    @GetMapping("/content/{id}/detail")
//    public String detailContent(@PathVariable("id") Integer id, Model model) {
@GetMapping("/content/detail")
public String detailContent(Integer id, Model model) {
// URL 경로 변수인 {id}를 받으려면 @PathVariable을 써야 합니다.
ContentCreateDTO contentDTO = contentService.read(id);
model.addAttribute("contentDTO", contentDTO);
System.out.println("deteil id         ===>" + id);
System.out.println("deteil contentDTO ===>" + contentDTO);
return "content/detail"; // 경로가 정확한지 확인 필요
}

//
//    @GetMapping("/content/{id:\\d+}")
//    public String detail(@RequestParam("id") Integer id, Model model) {
//        ContentDetailDTO detailDTO = contentService.getContentDetail(id);
//        model.addAttribute("contentDTO", detailDTO.getContentInfo()); // ContentResponseDTO
//        model.addAttribute("gallery", detailDTO.getGallery());
//        model.addAttribute("videos", detailDTO.getVideos());
//        model.addAttribute("externalServices", detailDTO.getExternalServices());
//        return "content/detail";
//    }

    // 수정 폼 이동
    @GetMapping("/content/{id}/update")
    public String updateContent(@PathVariable("id") Integer id, Model model) {
        ContentCreateDTO contentDTO = contentService.read(id);
        model.addAttribute("contentDTO", contentDTO);
        return "content/update";
    }

    // 수정 처리 (→ 장르 수정 화면으로 리디렉트)
    @PostMapping("/content/{id}/update")
    public String updateContentProc(@PathVariable("id") Integer id, ContentCreateDTO contentDTO) {
//        contentService.update(id, contentDTO);
//        return "redirect:/content/list";
// Service에서 수정 처리 후 저장된 DTO 반환 받음
ContentCreateDTO savedContent = contentService.update(id, contentDTO);
//        System.out.println(" 22 savedContent ==" + savedContent);
// 수정 후 바로 장르 수정 페이지로 이동
return "redirect:/content/" + savedContent.getId() + "/genre";     // 장르 수정 폼으로 이동
}

    // 삭제 처리 (id를 @RequestParam 으로 받음)
    @GetMapping("/content/delete")
    public String deleteContent(@RequestParam("id") Integer id) {
        contentService.delete(id);
        return "redirect:/content/list";
    }

    // ==================== GENRE HANDLING ========================
    //콘텐츠 장르 등록/수정 페이지 {/content/{id}/genre)
    // 장르 선택/수정 폼
    @GetMapping("/content/{contentId}/genre")

    public String showGenreForm(@PathVariable Integer contentId, Model model) {
        ContentCreateDTO contentDTO = contentService.read(contentId);
        // 선택된 장르 (List<Genre>) → List<String>으로 변환
        List<Genre> selectedGenres = contentService.getGenresByContentId(contentId); // 이 메서드가 Enum List 반환
        List<String> selectedGenreNames = selectedGenres.stream()
                .map(Enum::name)
                .toList(); // ⚠️ 타입: List<Genre>// ✅ 템플릿에서 체크하기 좋게
        model.addAttribute("selectedGenres", selectedGenreNames); // ✅ 수정: 항상 String 리스트로
        // 중복된 addAttribute 제거

//        model.addAttribute("selectedGenres", genreService.getSelectedGenreNames(contentId));  // 이미 선택된 경우 표시
//        model.addAttribute("genreTranslations", genreService.getGenreTranslations()); // 한글 이름 맵핑


        Genre[] allGenres = Genre.values();
        // 장르 번역 맵 (10개 초과이므로 Map.ofEntries 사용)
        Map<String, String> genreTranslations = Map.ofEntries(
                Map.entry("ACTION", "액션"),
                Map.entry("DRAMA", "드라마"),
                Map.entry("ROMANCE", "로맨스"),
                Map.entry("HORROR", "호러"),
                Map.entry("THRILLER", "스릴러"),
                Map.entry("COMEDY", "코미디"),
                Map.entry("FANTASY", "판타지"),
                Map.entry("ADVENTURE", "어드벤처"),
                Map.entry("NATURAL_SCIENCE", "자연과학"),
                Map.entry("KPOP", "K-POP"),
                Map.entry("ANIMATION", "애니메이션"),
                Map.entry("SPORTS", "스포츠"),
                Map.entry("MYSTERY", "미스터리"),
                Map.entry("DOCUMENTARY", "다큐멘터리"),
                Map.entry("SF", "SF"),
                Map.entry("MUSIC", "음악"),
                Map.entry("FAMILY", "가족"),
                Map.entry("CONCERT", "공연실황"),
                Map.entry("MUSICAL", "뮤지컬"),
                Map.entry("BIOPIC", "전기"),
                Map.entry("HISTORY", "역사"),
                Map.entry("CRIME", "범죄"),
                Map.entry("KIDS", "키즈"),
                Map.entry("VARIETY", "예능"),
                Map.entry("SITCOM", "시트콤"),
                Map.entry("PERIOD", "시대극"),
                Map.entry("ROMANTIC_COMEDY", "로맨틱 코미디"),
                Map.entry("BL", "BL"),
                Map.entry("TEENAGER", "틴에이저"),
                Map.entry("DISASTER", "재난"),
                Map.entry("COMICS", "만화"),
                Map.entry("HUMANITIES", "인문학"),
                Map.entry("ECONOMICS", "경제서"),
                Map.entry("INVESTMENT", "투자서"),
                Map.entry("NOVEL", "소설"),
                Map.entry("ESSAY", "에세이"),
                Map.entry("SELF_HELP", "자기계발"),
                Map.entry("WAR", "전쟁"),
                Map.entry("PLAY", "희곡"),
                Map.entry("POETRY", "시"),
                Map.entry("SLICE_OF_LIFE", "일상"),
                Map.entry("HIP_HOP", "힙합"),
                Map.entry("POP", "팝"),
                Map.entry("MOVIE_SOUNDTRACK", "영화음악"),
                Map.entry("TV_SOUNDTRACK", "드라마음악"),
                Map.entry("BALLAD", "발라드"),
                Map.entry("DANCE", "댄스"),
                Map.entry("ROCK", "록"),
                Map.entry("CLASSICAL", "클래식"),
                Map.entry("INDIE", "인디"),
                Map.entry("ELECTRONICA", "일렉트로니카"),
                Map.entry("JPOP", "JPOP"),
                Map.entry("RNB", "알앤비"),
                Map.entry("TROT", "트로트")
        );

        // 해당 contentId로 ContentDTO, 모든 장르 리스트, 선택된 장르 리스트, 장르 번역 등을 모델에 추가
        // 모델에 필요한 데이터 전달
        model.addAttribute("contentDTO", contentDTO);
        model.addAttribute("contentId", contentId);
        model.addAttribute("allGenres", Genre.values());
        model.addAttribute("selectedGenres", selectedGenreNames); // ✅ String 리스트로!
        model.addAttribute("genreTranslations", genreTranslations);


        System.out.println(" get33 contentDTO ==" + contentDTO);
        System.out.println(" get33 contentId ==" + contentId);
        System.out.println(" get33 allGenres ==" + allGenres);
        System.out.println(" get33 selectedGenres ==" + selectedGenres);
        System.out.println(" get33 genreTranslations ==" + genreTranslations);
        System.out.println(" ---------------------");

        return "content/genreForm"; // 장르 선택 HTML
    }
    //********************************************************************************//

    //********************************************************************************//
    // 장르 저장
    @PostMapping("/content/{contentId}/genre")
    public String submitGenres(@PathVariable("contentId") Integer contentId,
                               @RequestParam(value = "genres", required = false) List<Genre> genres,
                               Model model) {

        System.out.println(" post 44 contentId  ==" + contentId);
        System.out.println(" post 44 genress    ==" + genres);
        System.out.println(" ---------------------");
//        contentService.updateGenres(contentId, genres != null ? genres :
//                List.of());

        // 장르 업데이트 (null 허용, 빈 리스트 처리 포함)
        contentService.updateGenres(contentId, genres != null ? genres : List.of());

        // 업데이트된 내용 화면에 전달
        ContentCreateDTO contentDTO = contentService.read(contentId);
        List<Genre> selectedGenres = contentService.getGenresByContentId(contentId);
        List<String> selectedGenreNames = selectedGenres.stream()
                .map(Enum::name).collect(Collectors.toList());
        // 모델에 필요한 데이터 다시 담기 (✅ 중요)
        // ✅ redirect 이후 model 사용하지 않으므로, addAttribute 생략

        Genre[] allGenres = Genre.values();
        // 장르 번역 맵 (10개 초과이므로 Map.ofEntries 사용)
        Map<String, String> genreTranslations = Map.ofEntries(
                Map.entry("ACTION", "액션"),
                Map.entry("DRAMA", "드라마"),
                Map.entry("ROMANCE", "로맨스"),
                Map.entry("HORROR", "호러"),
                Map.entry("THRILLER", "스릴러"),
                Map.entry("COMEDY", "코미디"),
                Map.entry("FANTASY", "판타지"),
                Map.entry("ADVENTURE", "어드벤처"),
                Map.entry("NATURAL_SCIENCE", "자연과학"),
                Map.entry("KPOP", "K-POP"),
                Map.entry("ANIMATION", "애니메이션"),
                Map.entry("SPORTS", "스포츠"),
                Map.entry("MYSTERY", "미스터리"),
                Map.entry("DOCUMENTARY", "다큐멘터리"),
                Map.entry("SF", "SF"),
                Map.entry("MUSIC", "음악"),
                Map.entry("FAMILY", "가족"),
                Map.entry("CONCERT", "공연실황"),
                Map.entry("MUSICAL", "뮤지컬"),
                Map.entry("BIOPIC", "전기"),
                Map.entry("HISTORY", "역사"),
                Map.entry("CRIME", "범죄"),
                Map.entry("KIDS", "키즈"),
                Map.entry("VARIETY", "예능"),
                Map.entry("SITCOM", "시트콤"),
                Map.entry("PERIOD", "시대극"),
                Map.entry("ROMANTIC_COMEDY", "로맨틱 코미디"),
                Map.entry("BL", "BL"),
                Map.entry("TEENAGER", "틴에이저"),
                Map.entry("DISASTER", "재난"),
                Map.entry("COMICS", "만화"),
                Map.entry("HUMANITIES", "인문학"),
                Map.entry("ECONOMICS", "경제서"),
                Map.entry("INVESTMENT", "투자서"),
                Map.entry("NOVEL", "소설"),
                Map.entry("ESSAY", "에세이"),
                Map.entry("SELF_HELP", "자기계발"),
                Map.entry("WAR", "전쟁"),
                Map.entry("PLAY", "희곡"),
                Map.entry("POETRY", "시"),
                Map.entry("SLICE_OF_LIFE", "일상"),
                Map.entry("HIP_HOP", "힙합"),
                Map.entry("POP", "팝"),
                Map.entry("MOVIE_SOUNDTRACK", "영화음악"),
                Map.entry("TV_SOUNDTRACK", "드라마음악"),
                Map.entry("BALLAD", "발라드"),
                Map.entry("DANCE", "댄스"),
                Map.entry("ROCK", "록"),
                Map.entry("CLASSICAL", "클래식"),
                Map.entry("INDIE", "인디"),
                Map.entry("ELECTRONICA", "일렉트로니카"),
                Map.entry("JPOP", "JPOP"),
                Map.entry("RNB", "알앤비"),
                Map.entry("TROT", "트로트")
        );
       // redirect: 후 model.addAttribute()는 무의미함


        return "redirect:/content/" + contentId + "/genre";

    }

}package com.example.itview_spring.Controller.Content;

import com.example.itview_spring.Constant.Genre;
import com.example.itview_spring.DTO.ContentCreateDTO;
import com.example.itview_spring.DTO.ContentDetailDTO;
import com.example.itview_spring.DTO.PageInfoDTO;
import com.example.itview_spring.Service.ContentService;
import com.example.itview_spring.Util.PageInfo;
import lombok.RequiredArgsConstructor;
import org.springframework.boot.web.servlet.error.ErrorController;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.web.PageableDefault;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.*;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import static org.springframework.data.jpa.domain.AbstractPersistable_.id;

@Controller
@RequiredArgsConstructor
public class ContentController {
private final ContentService contentService;
private final PageInfo pageInfo;

    // ==================== ERROR PAGE HANDLER ====================
    //    500 에러가 나더라도 커스텀 오류 페이지 추가 가능 (선택 사항)-----------------------------------
//    @Controller
//    public class CustomErrorController implements ErrorController {
//        @RequestMapping("/error")
//        public String handleError() {
//            return "error/customError"; // templates/error/customError.html
//        }
//    }
// ==================== CONTENT CRUD ==========================
// 등록 폼 이동
@GetMapping("/content/register")
public String newContent() {

        return "content/register";
    }

    // 등록 처리 후 → 장르 선택 페이지로 이동
    @PostMapping("/content/register")
    public String newContent(ContentCreateDTO contentDTO) {
        //데이터 저장처리 (Service -> Controller
        ContentCreateDTO savedContent = contentService.create(contentDTO); // 저장 후

        System.out.println(" 00 savedContent ==" + savedContent);
        return "redirect:/content/" + savedContent.getId() + "/genre";     // 장르 등록 폼으로 이동
        //   return "redirect:/content/list";  // 리스트 이동 옵션 (현재는 장르 선택 우선)
    }


    //localhost:8080/content/list 확인함(@GetMppping
    //전체강의 조회후 (list.html)로이동

    /**
     * 전체조회
     *
     * @param pageable 조회할 페이지 번호 /페이징 정보 (기본 페이지 1)
     * @param model    결좌 전달 /뷰에 전달할 모델
     * @return 페이지 이동 /뷰
     */
    @GetMapping("/content/list")
    // 전체 목록 조회
    public String listContent(@PageableDefault(page = 1) Pageable pageable, Model model) {
        //모든 데이터를 조회
        //keyword  추가 ****
        Page<ContentCreateDTO> contentDTOS = contentService.getAllContents(pageable);
        model.addAttribute("contentDTOS", contentDTOS);
        //    System.out.println("contentDTO.            ==", contentDTOS);

        // 페이지 정보 생성 후 모델에 추가
        PageInfoDTO pageInfoDTO = pageInfo.getPageInfo(contentDTOS);
        model.addAttribute("pageInfoDTO", pageInfoDTO);
//        model.addAttribute("contentDTOS", contentDTOS);
//        model.addAttribute("pageInfoDTO", pageInfo.getPageInfo(contentDTOS));
return "content/list";
}

    // 상세 보기 (id 파라미터로 받음, @PathVariable 대신 @RequestParam 형식)
// @GetMapping("/content/{id:\\d+}")
//    @GetMapping("/content/detail")
//    @GetMapping("/content/{id}/detail")
//    public String detailContent(@PathVariable("id") Integer id, Model model) {
@GetMapping("/content/detail")
public String detailContent(Integer id, Model model) {
// URL 경로 변수인 {id}를 받으려면 @PathVariable을 써야 합니다.
ContentCreateDTO contentDTO = contentService.read(id);
model.addAttribute("contentDTO", contentDTO);
System.out.println("deteil id         ===>" + id);
System.out.println("deteil contentDTO ===>" + contentDTO);
return "content/detail"; // 경로가 정확한지 확인 필요
}

//
//    @GetMapping("/content/{id:\\d+}")
//    public String detail(@RequestParam("id") Integer id, Model model) {
//        ContentDetailDTO detailDTO = contentService.getContentDetail(id);
//        model.addAttribute("contentDTO", detailDTO.getContentInfo()); // ContentResponseDTO
//        model.addAttribute("gallery", detailDTO.getGallery());
//        model.addAttribute("videos", detailDTO.getVideos());
//        model.addAttribute("externalServices", detailDTO.getExternalServices());
//        return "content/detail";
//    }

    // 수정 폼 이동
    @GetMapping("/content/{id}/update")
    public String updateContent(@PathVariable("id") Integer id, Model model) {
        ContentCreateDTO contentDTO = contentService.read(id);
        model.addAttribute("contentDTO", contentDTO);
        return "content/update";
    }

    // 수정 처리 (→ 장르 수정 화면으로 리디렉트)
    @PostMapping("/content/{id}/update")
    public String updateContentProc(@PathVariable("id") Integer id, ContentCreateDTO contentDTO) {
//        contentService.update(id, contentDTO);
//        return "redirect:/content/list";
// Service에서 수정 처리 후 저장된 DTO 반환 받음
ContentCreateDTO savedContent = contentService.update(id, contentDTO);
//        System.out.println(" 22 savedContent ==" + savedContent);
// 수정 후 바로 장르 수정 페이지로 이동
return "redirect:/content/" + savedContent.getId() + "/genre";     // 장르 수정 폼으로 이동
}

    // 삭제 처리 (id를 @RequestParam 으로 받음)
    @GetMapping("/content/delete")
    public String deleteContent(@RequestParam("id") Integer id) {
        contentService.delete(id);
        return "redirect:/content/list";
    }

    // ==================== GENRE HANDLING ========================
    //콘텐츠 장르 등록/수정 페이지 {/content/{id}/genre)
    // 장르 선택/수정 폼
    @GetMapping("/content/{contentId}/genre")

    public String showGenreForm(@PathVariable Integer contentId, Model model) {
        ContentCreateDTO contentDTO = contentService.read(contentId);
        // 선택된 장르 (List<Genre>) → List<String>으로 변환
        List<Genre> selectedGenres = contentService.getGenresByContentId(contentId); // 이 메서드가 Enum List 반환
        List<String> selectedGenreNames = selectedGenres.stream()
                .map(Enum::name)
                .toList(); // ⚠️ 타입: List<Genre>// ✅ 템플릿에서 체크하기 좋게
        model.addAttribute("selectedGenres", selectedGenreNames); // ✅ 수정: 항상 String 리스트로
        // 중복된 addAttribute 제거

//        model.addAttribute("selectedGenres", genreService.getSelectedGenreNames(contentId));  // 이미 선택된 경우 표시
//        model.addAttribute("genreTranslations", genreService.getGenreTranslations()); // 한글 이름 맵핑


        Genre[] allGenres = Genre.values();
        // 장르 번역 맵 (10개 초과이므로 Map.ofEntries 사용)
        Map<String, String> genreTranslations = Map.ofEntries(
                Map.entry("ACTION", "액션"),
                Map.entry("DRAMA", "드라마"),
                Map.entry("ROMANCE", "로맨스"),
                Map.entry("HORROR", "호러"),
                Map.entry("THRILLER", "스릴러"),
                Map.entry("COMEDY", "코미디"),
                Map.entry("FANTASY", "판타지"),
                Map.entry("ADVENTURE", "어드벤처"),
                Map.entry("NATURAL_SCIENCE", "자연과학"),
                Map.entry("KPOP", "K-POP"),
                Map.entry("ANIMATION", "애니메이션"),
                Map.entry("SPORTS", "스포츠"),
                Map.entry("MYSTERY", "미스터리"),
                Map.entry("DOCUMENTARY", "다큐멘터리"),
                Map.entry("SF", "SF"),
                Map.entry("MUSIC", "음악"),
                Map.entry("FAMILY", "가족"),
                Map.entry("CONCERT", "공연실황"),
                Map.entry("MUSICAL", "뮤지컬"),
                Map.entry("BIOPIC", "전기"),
                Map.entry("HISTORY", "역사"),
                Map.entry("CRIME", "범죄"),
                Map.entry("KIDS", "키즈"),
                Map.entry("VARIETY", "예능"),
                Map.entry("SITCOM", "시트콤"),
                Map.entry("PERIOD", "시대극"),
                Map.entry("ROMANTIC_COMEDY", "로맨틱 코미디"),
                Map.entry("BL", "BL"),
                Map.entry("TEENAGER", "틴에이저"),
                Map.entry("DISASTER", "재난"),
                Map.entry("COMICS", "만화"),
                Map.entry("HUMANITIES", "인문학"),
                Map.entry("ECONOMICS", "경제서"),
                Map.entry("INVESTMENT", "투자서"),
                Map.entry("NOVEL", "소설"),
                Map.entry("ESSAY", "에세이"),
                Map.entry("SELF_HELP", "자기계발"),
                Map.entry("WAR", "전쟁"),
                Map.entry("PLAY", "희곡"),
                Map.entry("POETRY", "시"),
                Map.entry("SLICE_OF_LIFE", "일상"),
                Map.entry("HIP_HOP", "힙합"),
                Map.entry("POP", "팝"),
                Map.entry("MOVIE_SOUNDTRACK", "영화음악"),
                Map.entry("TV_SOUNDTRACK", "드라마음악"),
                Map.entry("BALLAD", "발라드"),
                Map.entry("DANCE", "댄스"),
                Map.entry("ROCK", "록"),
                Map.entry("CLASSICAL", "클래식"),
                Map.entry("INDIE", "인디"),
                Map.entry("ELECTRONICA", "일렉트로니카"),
                Map.entry("JPOP", "JPOP"),
                Map.entry("RNB", "알앤비"),
                Map.entry("TROT", "트로트")
        );

        // 해당 contentId로 ContentDTO, 모든 장르 리스트, 선택된 장르 리스트, 장르 번역 등을 모델에 추가
        // 모델에 필요한 데이터 전달
        model.addAttribute("contentDTO", contentDTO);
        model.addAttribute("contentId", contentId);
        model.addAttribute("allGenres", Genre.values());
        model.addAttribute("selectedGenres", selectedGenreNames); // ✅ String 리스트로!
        model.addAttribute("genreTranslations", genreTranslations);


        System.out.println(" get33 contentDTO ==" + contentDTO);
        System.out.println(" get33 contentId ==" + contentId);
        System.out.println(" get33 allGenres ==" + allGenres);
        System.out.println(" get33 selectedGenres ==" + selectedGenres);
        System.out.println(" get33 genreTranslations ==" + genreTranslations);
        System.out.println(" ---------------------");

        return "content/genreForm"; // 장르 선택 HTML
    }
    //********************************************************************************//

    //********************************************************************************//
    // 장르 저장
    @PostMapping("/content/{contentId}/genre")
    public String submitGenres(@PathVariable("contentId") Integer contentId,
                               @RequestParam(value = "genres", required = false) List<Genre> genres,
                               Model model) {

        System.out.println(" post 44 contentId  ==" + contentId);
        System.out.println(" post 44 genress    ==" + genres);
        System.out.println(" ---------------------");
//        contentService.updateGenres(contentId, genres != null ? genres :
//                List.of());

        // 장르 업데이트 (null 허용, 빈 리스트 처리 포함)
        contentService.updateGenres(contentId, genres != null ? genres : List.of());

        // 업데이트된 내용 화면에 전달
        ContentCreateDTO contentDTO = contentService.read(contentId);
        List<Genre> selectedGenres = contentService.getGenresByContentId(contentId);
        List<String> selectedGenreNames = selectedGenres.stream()
                .map(Enum::name).collect(Collectors.toList());
        // 모델에 필요한 데이터 다시 담기 (✅ 중요)
        // ✅ redirect 이후 model 사용하지 않으므로, addAttribute 생략

        Genre[] allGenres = Genre.values();
        // 장르 번역 맵 (10개 초과이므로 Map.ofEntries 사용)
        Map<String, String> genreTranslations = Map.ofEntries(
                Map.entry("ACTION", "액션"),
                Map.entry("DRAMA", "드라마"),
                Map.entry("ROMANCE", "로맨스"),
                Map.entry("HORROR", "호러"),
                Map.entry("THRILLER", "스릴러"),
                Map.entry("COMEDY", "코미디"),
                Map.entry("FANTASY", "판타지"),
                Map.entry("ADVENTURE", "어드벤처"),
                Map.entry("NATURAL_SCIENCE", "자연과학"),
                Map.entry("KPOP", "K-POP"),
                Map.entry("ANIMATION", "애니메이션"),
                Map.entry("SPORTS", "스포츠"),
                Map.entry("MYSTERY", "미스터리"),
                Map.entry("DOCUMENTARY", "다큐멘터리"),
                Map.entry("SF", "SF"),
                Map.entry("MUSIC", "음악"),
                Map.entry("FAMILY", "가족"),
                Map.entry("CONCERT", "공연실황"),
                Map.entry("MUSICAL", "뮤지컬"),
                Map.entry("BIOPIC", "전기"),
                Map.entry("HISTORY", "역사"),
                Map.entry("CRIME", "범죄"),
                Map.entry("KIDS", "키즈"),
                Map.entry("VARIETY", "예능"),
                Map.entry("SITCOM", "시트콤"),
                Map.entry("PERIOD", "시대극"),
                Map.entry("ROMANTIC_COMEDY", "로맨틱 코미디"),
                Map.entry("BL", "BL"),
                Map.entry("TEENAGER", "틴에이저"),
                Map.entry("DISASTER", "재난"),
                Map.entry("COMICS", "만화"),
                Map.entry("HUMANITIES", "인문학"),
                Map.entry("ECONOMICS", "경제서"),
                Map.entry("INVESTMENT", "투자서"),
                Map.entry("NOVEL", "소설"),
                Map.entry("ESSAY", "에세이"),
                Map.entry("SELF_HELP", "자기계발"),
                Map.entry("WAR", "전쟁"),
                Map.entry("PLAY", "희곡"),
                Map.entry("POETRY", "시"),
                Map.entry("SLICE_OF_LIFE", "일상"),
                Map.entry("HIP_HOP", "힙합"),
                Map.entry("POP", "팝"),
                Map.entry("MOVIE_SOUNDTRACK", "영화음악"),
                Map.entry("TV_SOUNDTRACK", "드라마음악"),
                Map.entry("BALLAD", "발라드"),
                Map.entry("DANCE", "댄스"),
                Map.entry("ROCK", "록"),
                Map.entry("CLASSICAL", "클래식"),
                Map.entry("INDIE", "인디"),
                Map.entry("ELECTRONICA", "일렉트로니카"),
                Map.entry("JPOP", "JPOP"),
                Map.entry("RNB", "알앤비"),
                Map.entry("TROT", "트로트")
        );
       // redirect: 후 model.addAttribute()는 무의미함


        return "redirect:/content/" + contentId + "/genre";

    }

}<!DOCTYPE html>
<html lang="kr"
      xmlns:th="http://www.thymeleaf.org"
      xmlns:layout="http://www.ultraq.net.nz/thymeleaf/layout"
      layout:decorate="~{layouts/mainlayout}">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
<main layout:fragment="content">
    <!--    <h1>Welcome to the Dashboard</h1>-->
    <!--    <p>This is your main content area.</p>-->

    <div class="container mt-5">
        <h2>콘텐츠 장르 등록/수정</h2>

        <!--        <form th:action="@{|/content/${contentId}/genre|}" method="post">-->
        <form th:action="@{/content/{contentId}/genre(contentId=${contentDTO.id})}" method="post">
            <!-- ✅ CSRF 토큰 추가 (Spring Security 사용하는 경우 필수) -->
            <!--            <input type="hidden" th:name="${_csrf.parameterName}" th:value="${_csrf.token}"/>-->
            <input id="id" th:value="${contentDTO.id}" value="post" hidden>
            <!--            <input type="hidden" name="_method" value="post" />-->

            <div class="mb-3">
                <label class="form-label">장르 선택</label>
                <!-- ✅ 각 장르 체크박스 반복 출력 -->
                <!--                <div>-->
                <!--                    <ul>-->
                <!--                        &lt;!&ndash; 장르 리스트 출력 &ndash;&gt;-->
                <!--                        <c:forEach var="genre" items="${allGenres}">-->
                <!--                            <li>-->
                <!--                                <input type="checkbox" id="genre_${genre}" name="genres" value="${genre}"-->
                <!--                                <c:if test="${selectedGenres.contains(genre.name)}">checked</c:if> />-->
                <!--                                <label for="genre_${genre}">${genreTranslations[genre]}</label>-->
                <!--                            </li>-->
                <!--                        </c:forEach>-->
                <!--                    </ul>-->
                <!--                </div>-->
                <div class="form-check" th:each="genre : ${allGenres}">
                    <input class="form-check-input" type="checkbox" name="genres"
                           th:id="${'genre-' + genre.name()}"
                           th:value="${genre.name()}"
                           th:checked="${selectedGenres != null and selectedGenres.contains(genre.name())}"/>

                    <label class="form-check-label"
                           th:for="${'genre-' + genre.name()}"
                           th:text="${genreTranslations[genre.name()]}">장르명</label>
                </div>


                <!--                       th:text="${genre.genreName}">장르명</label>-->

                <!-- ✅ 한글명 변환은 선택적으로 ENUM에 메서드 추가 -->
                <!--                    <label class="form-check-label"-->
                <!--                           th:for="${'genre-' + genre.name()}"-->
                <!--                              th:text="${genre.genreName}">-->
                <!--                           th:text="${#strings.equalsIgnoreCase(genre.name(), 'ACTION') ? '액션' :-->
                <!--                                      #strings.equalsIgnoreCase(genre.name(), 'ADVENTURE') ? '어드벤처' :-->
                <!--                                      #strings.equalsIgnoreCase(genre.name(), 'COMEDY') ? '코미디' :-->
                <!--                                      #strings.equalsIgnoreCase(genre.name(), 'DRAMA') ? '드라마' :-->
                <!--                                      #strings.equalsIgnoreCase(genre.name(), 'THRILLER') ? '스릴러' :-->
                <!--                                      #strings.equalsIgnoreCase(genre.name(), 'HORROR') ? '호러' :-->
                <!--                                      #strings.equalsIgnoreCase(genre.name(), 'FANTASY') ? '판타지' :-->
                <!--                                      #strings.equalsIgnoreCase(genre.name(), 'ROMANCE') ? '로맨스' :-->
                <!--                                      #strings.equalsIgnoreCase(genre.name(), 'NATURAL_SCIENCE') ? '자연과학' :-->
                <!--                                      #strings.equalsIgnoreCase(genre.name(), 'KPOP') ? 'K-POP' :-->
                <!--                                      genre.name())))))))))">-->
                <!--                            <span th:text="${genre.genreName}">장르</span>-->
                <!--                            장르명-->
                <!--                    </label>-->

            </div>

            <button type="submit" class="btn btn-primary">저장</button>
            <a th:href="@{/content/list}" class="btn btn-secondary">취소</a>
        </form>
        <!-- 수정된 후 데이터 보기 -->
        <h3>선택한 장르 </h3>
        <ul>
            <th:block th:each="genre : ${selectedGenres}">
<!--               selectedGenres가 List<String>이면 genre.name() 호출 불가 → 오류 발생-->
<!--                <li th:text="${genreTranslations[genre.name()]}"></li>-->
                <li th:text="${genreTranslations[genre]}"></li>
            </th:block>
        </ul>

<!--        &lt;!&ndash; 수정된 후 데이터 보기 &ndash;&gt;-->
<!--        <h3>선택된 장르</h3>-->
<!--        <ul>-->
<!--            <c:forEach var="genre" items="${selectedGenres}">-->
<!--                <li>${genre}</li>-->
<!--            </c:forEach>-->
<!--        </ul>-->
<!--        -->

    </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>

</main>
</body>
</html>  controller service html    수정할곳 전과 후 비교 자료 확인해줘 


ChatGPT의 말:
제출한 메시지가 너무 깁니다. 수정해 다시 제출하세요.


다시 시도



첨부

검색

학습하기

음성
선택된 파일 없음선택된 파일 없음
ChatGPT는 실수를 할 수 있습니다. 중요한 정보는 재차 확인하세요.
